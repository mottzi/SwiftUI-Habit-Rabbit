// ./Habit Rabbit/App/HabitRabbit.swift
import SwiftUI
import SwiftData

@main
struct HabitRabbit: App {
    
    let modelContainer: ModelContainer
    let dashboardManager: Habit.Dashboard.Manager
    
    var body: some Scene {
        WindowGroup {
            Habit.Dashboard()
                .environment(dashboardManager)
                .fontDesign(.rounded)
        }
    }
    
    init() {
        modelContainer = try! ModelContainer(for: Habit.self, Habit.Value.self)
        dashboardManager = Habit.Dashboard.Manager(using: modelContainer.mainContext)
    }
    
}
// ./Habit Rabbit/App/Extensions/Calendar.swift
import SwiftUI

extension Date {
    
    var tomorrow: Date {
        Calendar.current.date(byAdding: .day, value: 1, to: self)!
    }
    
    var yesterday: Date {
        Calendar.current.date(byAdding: .day, value: -1, to: self)!
    }
    
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }

    func shift(days dayOffset: Int) -> Date {
        Calendar.current.date(byAdding: .day, value: dayOffset, to: self)!
    }
    
    func isSameDay(as other: Date) -> Bool {
        Calendar.current.isDate(self, inSameDayAs: other)
    }
    
    var formatted: String {
        let formatter = DateFormatter()
        formatter.locale = Locale.preferred
        formatter.setLocalizedDateFormatFromTemplate("EEEEddMMyyyy")
        return formatter.string(from: self)
    }

    var formatted2: String {
        let formatter = DateFormatter()
        formatter.locale = Locale.preferred
        formatter.setLocalizedDateFormatFromTemplate("ddMMyyyy")
        return formatter.string(from: self)
    }
    
    var debug: String {
        let formatter = DateFormatter()
        formatter.locale = .current
        formatter.timeZone = .current
        formatter.dateFormat = "EEEE, dd.MM.yyyy, HH:mm:ss"
        return formatter.string(from: self)
    }
    
}

extension Calendar {
    
    var weekdaySymbols: [String] {
        let formatter = DateFormatter()
        formatter.locale = Locale.preferred
        guard let symbols = formatter.veryShortWeekdaySymbols, !symbols.isEmpty else { return [] }
        let first = (firstWeekday - 1) % symbols.count
        let rotated = Array(symbols[first...] + symbols[..<first])
        return rotated
    }
    
    // compute zero-based weekday column index aligned to calendar.firstWeekday
    func weekdayIndex(for date: Date) -> Int {
        // get 1-based weekday component for the given date
        let weekday = component(.weekday, from: date)
        // normalize to zero-based index relative to firstWeekday
        return (weekday - firstWeekday + 7) % 7
    }
    
}

extension Locale {
    
    static var preferred: Locale {
        if let preferredIdentifier = Locale.preferredLanguages.first {
            return Locale(identifier: preferredIdentifier)
        } else {
            return Locale.current
        }
    }
    
}
// ./Habit Rabbit/App/Extensions/Collections.swift
import SwiftUI

extension CaseIterable where Self: Equatable, AllCases: BidirectionalCollection {
    
    var next: Self {
        let all = Self.allCases
        let current = all.firstIndex(of: self)!
        let next = all.index(after: current)
        return all[next == all.endIndex ? all.startIndex : next]
    }
    
    var previous: Self {
        let all = Self.allCases
        let current = all.firstIndex(of: self)!
        let previous = current == all.startIndex ? all.index(before: all.endIndex) : all.index(before: current)
        return all[previous]
    }
    
    var isFirst: Bool {
        Self.allCases.first == self
    }
    
    var isLast: Bool {
        Self.allCases.last == self
    }
    
}

extension RandomAccessCollection {

    var enumerated: [(offset: Int, element: Element)] {
        Array(self.enumerated())
    }
    
}
// ./Habit Rabbit/App/Extensions/Notifications.swift
import SwiftUI
import Combine

extension View {
    
    func onCalendarDayChanged(action: @escaping () -> Void) -> some View {
        self.task {
            for await _ in NotificationCenter.default.notifications(named: .NSCalendarDayChanged) {
                action()
            }
        }
    }
    
}
// ./Habit Rabbit/App/Extensions/String.swift
import SwiftUI

extension String {

    func pluralized(count: Int) -> String {
        return String.pluralize(string: self, count: count)
    }
    
    static func pluralize(string: String, count: Int) -> String {
        let query = LocalizationValue(String("^[\(count) \(string)](inflect: true)"))
        let attributed = AttributedString(localized: query)
        let localized = String(attributed.characters)
        let prefix = "\(count) "
        guard localized.hasPrefix(prefix) else { return localized }
        return String(localized.dropFirst(prefix.count))
    }
}


// ./Habit Rabbit/App/Extensions/View.swift
import SwiftUI

extension View {

    func debug(_ color: Color? = nil, _ width: CGFloat? = nil) -> some View {
        self.border(color ?? .orange, width: width ?? 2)
    }
    
    @ViewBuilder
    func `if`<TrueContent: View, FalseContent: View>(
        _ condition: Bool,
        @ViewBuilder trueTransform: (Self) -> TrueContent,
        @ViewBuilder `else`: (Self) -> FalseContent
    ) -> some View {
        if condition {
            trueTransform(self)
        } else {
            `else`(self)
        }
    }
    
    @ViewBuilder
    func `if`<TrueContent: View>(
        _ condition: Bool,
        @ViewBuilder trueTransform: (Self) -> TrueContent
    ) -> some View {
        if condition {
            trueTransform(self)
        } else {
            self
        }
    }
    
}
// ./Habit Rabbit/App/Models/Habit.swift
import SwiftUI
import SwiftData

@Model
class Habit {

    var name: String
    var unit: String
    var icon: String
    var target: Int
    var date: Date
    var kind: Habit.Kind
    var colorData: Data

    @Relationship(deleteRule: .cascade, inverse: \Habit.Value.habit)
    var values: [Habit.Value]?
    
    init(
        name: String,
        unit: String,
        icon: String,
        color: Color,
        target: Int,
        kind: Habit.Kind
    ) {
        self.name = name
        self.unit = unit
        self.icon = icon
        self.target = target
        self.date = .now
        self.kind = kind
        self.colorData = (try? NSKeyedArchiver.archivedData(
            withRootObject: UIColor(color),
            requiringSecureCoding: false)
        ) ?? Data()
    }
    
    enum Kind: String, Codable {
        case good
        case bad
    }
    
}

extension Habit {

    private static var colorCache: [Data: Color] = [:]
    
    var color: Color {
        if let cached = Habit.colorCache[colorData] {
            return cached
        }
        
        if let uiColor = try? NSKeyedUnarchiver.unarchivedObject(ofClass: UIColor.self, from: colorData) {
            let color = Color(uiColor)
            Self.colorCache[colorData] = color
            return color
        }
        
        Habit.colorCache[colorData] = .black
        return .black
    }
    
}

extension ModelContext {
    
    func insert(habit: Habit) {
        insert(habit)
        let value = Habit.Value(habit: habit, date: habit.date)
        insert(value)
    }
    
}

extension Habit {
    
    static var examples: [Habit] {[
        Habit(name: "Hydration",
              unit: "bottle",
              icon: "drop.fill",
              color: .blue,
              target: 3,
              kind: .good,
        ),
        Habit(name: "Smoking",
              unit: "cigarette",
              icon: "figure.strengthtraining.functional",
              color: .orange,
              target: 3,
              kind: .bad,
        ),
        Habit(name: "Meditation",
              unit: "session",
              icon: "figure.mind.and.body",
              color: .green,
              target: 3,
              kind: .good,
        ),
        Habit(name: "Reading",
              unit: "page",
              icon: "books.vertical.fill",
              color: .pink,
              target: 4,
              kind: .good,
        ),
        Habit(name: "Stretching",
              unit: "session",
              icon: "figure.strengthtraining.functional",
              color: .teal,
              target: 10,
              kind: .good,
        ),
        Habit(name: "Chores",
              unit: "task",
              icon: "house.fill",
              color: .red,
              target: 6,
              kind: .good,
        ),
        Habit(name: "Vocabulary",
              unit: "word",
              icon: "book.fill",
              color: .indigo,
              target: 5,
              kind: .good,
        ),
        Habit(name: "Stretching",
              unit: "minute",
              icon: "figure.cooldown",
              color: .brown,
              target: 10,
              kind: .good,
        ),
        Habit(name: "Journaling",
              unit: "entry",
              icon: "pencil.and.ellipsis.rectangle",
              color: .cyan,
              target: 1,
              kind: .good,
        ),
    ]}
    
}
// ./Habit Rabbit/App/Models/Value.swift
import SwiftUI
import SwiftData

extension Habit {

    @Model
    class Value {
        
        @Relationship
        var habit: Habit?
        
        var date: Date
        var currentValue: Int
        
        init(habit: Habit, date: Date, currentValue: Int = 0) {
            self.habit = habit
            self.date = date.startOfDay
            self.currentValue = currentValue
        }
        
    }
    
}

extension Habit.Value {

    static func filterBy(day date: Date, for habit: Habit) -> FetchDescriptor<Habit.Value> {
        filterBy(days: 1, endingOn: date, for: habit)
    }
    
    static func filterBy(days: Int, endingOn date: Date, for habit: Habit) -> FetchDescriptor<Habit.Value> {
        let habitID = habit.id
        
        let today = Calendar.current.startOfDay(for: date)
        let rangeStart = Calendar.current.date(byAdding: .day, value: -(days-1), to: today)!
        let rangeEnd = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        
        let predicate = #Predicate<Habit.Value> { value in
//            value.habit?.id == habitID
            value.habit?.persistentModelID == habitID
            && value.date >= rangeStart && value.date < rangeEnd
        }
        
        let sortByDate = SortDescriptor(\Habit.Value.date)
        var descriptor = FetchDescriptor(predicate: predicate, sortBy: [sortByDate])
        descriptor.fetchLimit = days
        descriptor.relationshipKeyPathsForPrefetching = [\Habit.Value.habit]
        
        return descriptor
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Dashboard.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Dashboard {
    
    @Observable
    class Manager {

        private(set) var lastDay: Date
        private(set) var modelContext: ModelContext
        
        private(set) var mode: Habit.Card.Mode
        private(set) var useZoom: Bool = true
        private(set) var useInline: Bool = true
        
        private(set) var cardManagers: [Habit.Card.Manager] = []
        
        @ObservationIgnored
        private var cardManagerCache: [PersistentIdentifier: Habit.Card.Manager] = [:]
        
        let weekdaySymbols: [String]
        private(set) var lastDayIndex: Int
                
        init(
            mode: Habit.Card.Mode = .daily,
            lastDay: Date = .now.startOfDay,
            using modelContext: ModelContext
        ) {
            self.mode = mode
            self.lastDay = lastDay
            self.modelContext = modelContext
            
            self.weekdaySymbols = Calendar.current.weekdaySymbols
            self.lastDayIndex = Calendar.current.weekdayIndex(for: lastDay)
            
            refreshCardManagers()
        }
        
    }
    
}

extension Habit.Dashboard.Manager {
    
    // jump to yesterday or tomorrow with optimized single-day fetch
    func shiftLastDay(to direction: Habit.Card.Manager.DayShift) {
        
        // Update lastDay and lastDayIndex
        let offset = direction == .tomorrow ? 1 : -1
        lastDay = Calendar.current.date(byAdding: .day, value: offset, to: lastDay)!
        lastDayIndex = Calendar.current.weekdayIndex(for: lastDay)
        
        // Update existing card managers with the new lastDay
        for cardManager in cardManagers {
            cardManager.shiftLastDay(to: direction)
        }
    }
    
    // jump to arbitrary date with full refresh or to yesterday / tommorow with single-day-fetch
    func setLastDay(to date: Date) {
        guard !date.isSameDay(as: lastDay) else { return }
        let date = date.startOfDay
        
        let dayDifference = Calendar.current.dateComponents([.day], from: lastDay, to: date).day!
        
        // Use optimized path for single-day shifts (common case: midnight)
        if abs(dayDifference) == 1 {
            let direction: Habit.Card.Manager.DayShift = dayDifference > 0 ? .tomorrow : .yesterday
            shiftLastDay(to: direction)
        } else {
            // Fall back to full rebuild for larger jumps
            lastDay = date
            lastDayIndex = Calendar.current.weekdayIndex(for: date)
            deleteCardManagers()
            refreshCardManagers()
        }
    }
    
    // clear all card managers from cache
    func deleteCardManagers() {
        cardManagerCache.removeAll()
    }
    
    // rebuild all card managers from scratch
    func refreshCardManagers() {
        var newCache: [Habit.ID: Habit.Card.Manager] = [:]
        
        let query = FetchDescriptor<Habit>(sortBy: [SortDescriptor(\.date)])
        
        guard let habits = try? modelContext.fetch(query) else { return }
        
        for habit in habits {
            if let cachedManager = cardManagerCache[habit.id] {
                newCache[habit.id] = cachedManager
                continue
            }
            
            newCache[habit.id] = Habit.Card.Manager(
                for: habit,
                until: lastDay,
                mode: mode,
                using: modelContext
            )
        }
        
        self.cardManagerCache = newCache
        self.cardManagers = habits.compactMap { newCache[$0.id] }
        
    }
    
}

extension Habit.Dashboard.Manager {
    
    func toggleUseZoom() {
        useZoom.toggle()
    }
    
    func toggleUseInline() {
        useInline.toggle()
    }
        
    func updateMode(to newMode: Habit.Card.Mode) {
        if newMode == mode { return }
        mode = newMode
        synchronizeCardModes()
    }
    
    private func synchronizeCardModes() {
        cardManagers.forEach { $0.updateMode(to: mode) }
    }
    
    func weekdaySymbol(for date: Date) -> String {
        let index = Calendar.current.weekdayIndex(for: date)
        guard weekdaySymbols.indices.contains(index) else { return "?" }
        return weekdaySymbols[index]
    }
    
}

extension Habit.Dashboard.Manager {
    
    func randomizeAllHabits() {
        cardManagers.forEach { $0.randomizeMonthlyValues() }
    }
    
    func resetLatestHabits() {
        cardManagers.forEach { $0.resetDailyValue() }
    }
    
    func addHabits(_ habits: [Habit]) {
        habits.forEach { modelContext.insert(habit: $0) }
//        guard let _ = try? modelContext.save() else { return }

        do {
            try modelContext.save()
        } catch {
            print("Error adding habits: \(error)")
            return
        }
        refreshCardManagers()
    }
    
    func updateHabit(
        _ habit: Habit,
        name: String,
        unit: String,
        icon: String,
        color: Color,
        target: Int,
        kind: Habit.Kind
    ) {
        habit.name = name
        habit.unit = unit
        habit.icon = icon
        habit.target = target
        habit.kind = kind
        habit.colorData = (try? NSKeyedArchiver.archivedData(
            withRootObject: UIColor(color),
            requiringSecureCoding: false)
        ) ?? Data()
        
        guard let _ = try? modelContext.save() else { return }
        refreshCardManagers()
    }
    
    func updateHabit(_ habit: Habit, with newHabit: Habit) {
        updateHabit(
            habit,
            name: newHabit.name,
            unit: newHabit.unit,
            icon: newHabit.icon,
            color: newHabit.color,
            target: newHabit.target,
            kind: newHabit.kind
        )
    }
    
    func addExampleHabits(count: Int) {
        let templates = Habit.examples
        guard !templates.isEmpty else { return }
        
        let habits = (0..<count).map { i in
            let template = templates[i % templates.count]
            return Habit(
                name: template.name,
                unit: template.unit,
                icon: template.icon,
                color: template.color,
                target: template.target,
                kind: template.kind
            )
        }
        
        addHabits(habits)
    }
    
    func deleteAllHabits() throws {
        try modelContext.delete(model: Habit.self)
        try modelContext.save()
        refreshCardManagers()
    }
    
    func deleteAllData() {
        modelContext.container.deleteAllData()
        refreshCardManagers()
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Dashboard.swift
import SwiftUI

extension Habit {
    
    struct Dashboard: View {
        
        @Namespace private var habitTransition
        @Environment(\.colorScheme) var colorScheme

        @Environment(Habit.Dashboard.Manager.self) var dashboardManager
        var cardManagers: [Habit.Card.Manager] { dashboardManager.cardManagers }

        @State var presentAddSheet = false
        @State var habitToEdit: Habit?

        var body: some View {
            NavigationStack {
                ScrollView {
                    LazyVGrid(columns: columns, spacing: 16) {
                        ForEach(cardManagers.enumerated, id: \.element.habit.id) { index, cardManager in
                            NavigationLink {
                                Habit.Card.DetailView()
                                    .environment(cardManager)
                                    .environment(dashboardManager)
                                    .if(dashboardManager.useZoom) { view in
                                        view.navigationTransition(.zoom(sourceID: cardManager.habit.id, in: habitTransition))
                                    }
                            } label: {
                                Habit.Card { habitToEdit = $0 }
                                    .environment(cardManager)
                                    .environment(\.cardOffset, index)
                                    .if(dashboardManager.useZoom) { view in
                                        view.matchedTransitionSource(id: cardManager.habit.id, in: habitTransition)
                                    }
                            }
                            .buttonStyle(.plain)
                            .background { Habit.Card.shadowEffect(colorScheme) }
                        }
                    }
                    .safeAreaInset(edge: .top, spacing: 16) { gridHeader }
                    .padding([.horizontal, .bottom], 16)
                }
                .animation(.default, value: cardManagers.count)
                .sheet(isPresented: $presentAddSheet) { Sheet.Add() }
                .sheet(item: $habitToEdit) { Sheet.Edit(habit: $0) }
                .overlay(alignment: .bottomTrailing) { addHabitButton }
                .navigationTitle(String("Habit Rabbit"))
                .navigationBarTitleDisplayMode(dashboardManager.useInline ? .inline : .automatic)
                #if DEBUG
                .toolbar { debugButton }
                #endif
            }
            .tint(colorScheme == .dark ? .white : .black)
            .onCalendarDayChanged { dashboardManager.setLastDay(to: .now) }
        }
        
        private let columns = [
            GridItem(.flexible(), spacing: 16),
            GridItem(.flexible(), spacing: 16),
        ]
        
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.AddHabitButton.swift
import SwiftUI

extension Habit.Dashboard {
    
    var addHabitButton: some View {
        Button {
            presentAddSheet = true
        } label: {
            Image(systemName: "plus")
                .font(.title)
                .fontWeight(.medium)
                .foregroundStyle(colorScheme == .light ? .black : .white)
                .frame(width: 64, height: 64)
                .background { Habit.Card.Background(in: .circle, material: .ultraThinMaterial) }
                .padding()
        }
        .buttonStyle(.plain)
        .sensoryFeedback(.selection, trigger: presentAddSheet)
        .offset(x: 6, y: 0)
    }
    
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Debug.swift
import SwiftUI

extension Habit.Dashboard {
    
    var debugButton: some ToolbarContent {
        ToolbarItem {
            Menu {
                addExampleButton
                randomizeButton
                resetLatestButton
                Divider()
                zoomButton
                inlineButton
                Divider()
                killDatabaseButton
                deleteHabitsButton
            } label: {
                Image(systemName: "gearshape.fill")
                    .font(.system(size: 14, weight: .semibold))
                    .foregroundStyle(.primary)
                    .frame(width: 34, height: 34)
                    .background { Habit.Card.Background(in: .circle).showShadows(false) }
            }
            .buttonStyle(.plain)
        }
    }
    
}

extension Habit.Dashboard {
    
    var addExampleButton: some View {
        Menu {
            ForEach([1, 2, 4, 8, 20, 50, 100], id: \.self) { count in
                Button(String("\(count)")) {
                    dashboardManager.addExampleHabits(count: count)
                }
            }
        } label: {
            Label("Add Examples", systemImage: "plus")
        }
    }
    
    var randomizeButton: some View {
        Button("Randomize All", systemImage: "sparkles") {
            dashboardManager.randomizeAllHabits()
        }
    }
    
    var resetLatestButton: some View {
        Button("Reset Latest", systemImage: "0.circle") {
            dashboardManager.resetLatestHabits()
        }
    }
    
}

extension Habit.Dashboard {
    
    var zoomButton: some View {
        Button(action: dashboardManager.toggleUseZoom) {
            Label("Zoom Transition", systemImage: useZoomSymbol)
        }
    }
    
    var inlineButton: some View {
        Button(action: dashboardManager.toggleUseInline) {
            Label("Inline Title", systemImage: useInlineSymbol)
        }
    }
    
    var useZoomSymbol: String {
        dashboardManager.useZoom ? "checkmark.circle.fill" : "circle"
    }
    
    var useInlineSymbol: String {
        dashboardManager.useInline ? "checkmark.circle.fill" : "circle"
    }
    
}

extension Habit.Dashboard {
    
    var killDatabaseButton: some View {
        Button("Kill Database", systemImage: "xmark", role: .destructive) {
            dashboardManager.deleteAllData()
        }
    }
    
    var deleteHabitsButton: some View {
        Button("Delete All", systemImage: "trash", role: .destructive) {
            try? dashboardManager.deleteAllHabits()
        }
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Grid.Header.swift
import SwiftUI

extension Habit.Dashboard {
    
    var gridHeader: some View {
        VStack(spacing: 16) {
            modePicker
            dateView
        }
        .padding(.vertical, 6)
        .animation(.bouncy, value: dashboardManager.lastDay)
    }
    
}

extension Habit.Dashboard {
    
    private var modePicker: some View {
        ModePicker(
            width: 240,
            mode: dashboardManager.mode,
            onSelection: { mode in
                dashboardManager.updateMode(to: mode)
            }
        )
        .sensoryFeedback(.selection, trigger: dashboardManager.mode)
    }
    
}

extension Habit.Dashboard {
    
    private var dateView: some View {
        HStack(spacing: 16) {
            previousDayButton
            Text(dashboardManager.lastDay.formatted)
                .font(.system(size: 14, weight: .medium))
            nextDayButton
        }
    }
    
    private var previousDayButton: some View {
        Button {
            dashboardManager.shiftLastDay(to: .yesterday)
        } label: {
            Image(systemName: "chevron.left")
                .font(.system(size: 14, weight: .semibold))
                .foregroundStyle(.secondary)
                .frame(width: 34, height: 34)
                .background { Habit.Card.Background(in: .circle).showShadows(false) }
        }
        .buttonStyle(.plain)
        .sensoryFeedback(.selection, trigger: dashboardManager.lastDay)
    }
    
    private var nextDayButton: some View {
        Button {
            dashboardManager.shiftLastDay(to: .tomorrow)
        } label: {
            Image(systemName: "chevron.right")
                .font(.system(size: 14, weight: .semibold))
                .foregroundStyle(.secondary)
                .frame(width: 34, height: 34)
                .background { Habit.Card.Background(in: .circle).showShadows(false) }
        }
        .buttonStyle(.plain)
        .sensoryFeedback(.selection, trigger: dashboardManager.lastDay)
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Dashboard.Sheet.Keyboard.swift
import SwiftUI

extension Habit.Dashboard.Sheet {
    
    enum FocusedField: CaseIterable {
        case habitName
        case habitUnit
        case target
        case icon
    }
    
    func advanceToNextField(from currentField: FocusedField? = nil) {
        let currentField = currentField ?? focusedField
        guard let currentField else { return }
        let nextField = currentField.next
        
        if nextField == .icon {
            focusedField = .icon
            showIconPicker = true
            focusedField = nil
        } else {
            focusedField = nextField
        }
    }
    
    func advanceToPreviousField() {
        guard let currentField = focusedField else { return }
        focusedField = currentField.previous
    }
    
    var keyboardToolbar: some ToolbarContent {
        ToolbarItem(placement: .keyboard){
            HStack {
                Button("Previous") { advanceToPreviousField() }
                    .disabled(focusedField?.isFirst == true)
                    .fontWeight(.semibold)
                
                Button("Next") { advanceToNextField() }
                    .disabled(focusedField?.isLast == true)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("Done") { focusedField = nil }
                    .fontWeight(.semibold)
            }
        }
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Dashboard.Sheet.swift
import SwiftUI
import SwiftData

extension Habit.Dashboard {
    
    struct Sheet: View {
        
        @Environment(\.colorScheme) var colorScheme
        
        let initial: InitialValues
        let submitLabel: String
        let submitIcon: String
        let onSubmit: (Habit) -> ()
        
        @FocusState var focusedField: FocusedField?
        
        @State var name: String
        @State var unit: String
        @State var icon: String
        @State var selectedColorIndex: Int
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var kind: Habit.Kind
        
        let horizontalPadding: CGFloat = 16
        
        struct InitialValues {
            
            var name: String
            var unit: String
            var icon: String
            var color: Color
            var target: Int?
            var kind: Habit.Kind
            
        }
        
        init(
            initial: InitialValues,
            submitLabel: String,
            submitIcon: String,
            onSubmit: @escaping (Habit) -> ()
        ) {
            self.initial = initial
            self.submitLabel = submitLabel
            self.submitIcon = submitIcon
            self.onSubmit = onSubmit
            self._name = State(initialValue: initial.name)
            self._unit = State(initialValue: initial.unit)
            self._icon = State(initialValue: initial.icon)
            let colorIndex = Self.Edit.findClosestColorIndex(for: initial.color)
            self._selectedColorIndex = State(initialValue: colorIndex)
            self._targetValue = State(initialValue: initial.target)
            self._kind = State(initialValue: initial.kind)
        }
    }
}

extension Habit.Dashboard.Sheet {

    var body: some View {
        ScrollView {
            VStack(spacing: 14) {
                kindSection
                nameSection
                Divider()
                unitSection
                Divider()
                targetSection
                Divider()
                iconSection
                Divider()
                colorSection
            }
            .padding(horizontalPadding)
            .padding(.horizontal, horizontalPadding)
        }
        .scrollBounceBehavior(.basedOnSize)
        .overlay(alignment: .bottom) {
            Button(role: .none) {
                handleSubmit()
            } label: {
                Label(submitLabel, systemImage: submitIcon)
                    .fontWeight(.semibold)
            }
            .buttonStyle(.borderedProminent)
            .buttonBorderShape(.capsule)
            .tint(.blue)
            .disabled(!isFormValid)
            .padding(.vertical, 32)
        }
        .ignoresSafeArea(.keyboard)
        .toolbar { keyboardToolbar }
        .sheet(isPresented: $showIconPicker) { iconPickerSheet }
    }

}


extension Habit.Dashboard.Sheet {

    private var isFormValid: Bool {
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return false }
        guard !unit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return false }
        guard let targetValue, targetValue > 0 else { return false }
        return true
    }
    
    private func handleSubmit() {
        guard isFormValid, let targetValue else { return }
        let habit = Habit(
            name: name.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: unit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: icon,
            color: Self.availableColors[selectedColorIndex],
            target: targetValue,
            kind: kind
        )
        onSubmit(habit)
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Color.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var colorSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Color")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            colorPicker
        }
    }
    
    private var colorPicker: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                ForEach(Self.availableColors.enumerated, id: \.offset) { index, clr in
                    Button {
                        selectedColorIndex = index
                    } label: {
                        Circle()
                            .fill(clr.gradient)
                            .frame(width: 44, height: 44)
                            .overlay {
                                if selectedColorIndex == index {
                                    Circle()
                                        .strokeBorder(.primary, lineWidth: 3)
                                }
                            }
                    }
                    .buttonStyle(.plain)
                }
            }
        }
        .contentMargins(.horizontal, horizontalPadding * 2)
        .padding(.horizontal, -horizontalPadding * 2)
    }
    
    static let availableColors: [Color] = [
        .blue,
        .orange,
        .green,
        .pink,
        .mint,
        .purple,
        .yellow,
        .red,
        .teal,
        .indigo,
        .brown,
        .gray,
        .cyan,
    ]

}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Icon.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var iconSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Icon")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            iconPickerButton
                .font(.title3)
                .fontWeight(.semibold)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
    private var iconPickerButton: some View {
        Button {
            showIconPicker = true
        } label: {
            HStack(alignment: .lastTextBaseline) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundStyle(colorScheme == .light ? .black : .white)
                    .padding(.leading, 1)
                
                Text("Change")
                    .font(.subheadline)
                    .fontWeight(.bold)
                    .foregroundStyle(.secondary)
            }
        }
        .buttonStyle(.plain)
    }
        
    var iconPickerSheet: some View {
        NavigationStack {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 10) {
                    ForEach(Self.commonIcons, id: \.self) { icon in
                        Button {
                            Task {
                                self.icon = icon
                                try? await Task.sleep(for: .milliseconds(100))
                                showIconPicker = false
                                focusedField = nil
                            }
                        } label: {
                            Image(systemName: icon)
                                .font(.title3)
                                .foregroundStyle(icon == icon ? .white : (colorScheme == .light ? .black : .white))
                                .frame(width: 44, height: 44)
                                .padding(4)
                                .background {
                                    switch self.icon == icon {
                                        case true:  Circle().fill(.blue)
                                        case false: Habit.Card.Background(in: .circle)
                                    }
                                }
                            
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.vertical, 32)
                .padding(.horizontal, 16)
            }
            .toolbar { closeButton }
        }
        .presentationDetents([.large])
        .presentationBackground {
            Rectangle()
                .fill(.thickMaterial)
                .padding(.bottom, -100)
        }
    }
    
    private var closeButton: some ToolbarContent {
        ToolbarItem(placement: .topBarTrailing) {
            Button(role: .cancel) {
                showIconPicker = false
                focusedField = nil
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .tint(.red)
            .padding(.trailing, -8)
        }
    }
    
    var columns: [GridItem] {
        Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)
    }
    
    static let commonIcons: [String] = [
        "star.fill",
        "heart.fill",
        "flame.fill",
        "drop.fill",
        "leaf.fill",
        "moon.fill",
        "sun.max.fill",
        "cloud.rain.fill",
        "snowflake",
        "bolt.fill",
        "target",
        "book.fill",
        "pencil",
        "music.note",
        "camera.fill",
        "gamecontroller.fill",
        "figure.walk",
        "figure.run",
        "bicycle",
        "car.fill",
        "airplane",
        "house.fill",
        "building.2.fill",
        "cup.and.saucer.fill",
        "fork.knife",
        "pill.fill",
        "bed.double.fill",
        "laptopcomputer",
        "iphone",
        "headphones",
        "tv.fill",
        "film.fill",
        "gift.fill",
        "graduationcap.fill",
        "brain.head.profile",
        "dumbbell.fill",
        "lightbulb.fill",
        "paintbrush.fill",
        "wrench.fill",
        "briefcase.fill",
        "doc.text.fill",
        "calendar",
        "clock.fill",
        "alarm.fill",
        "bell.fill",
        "shield.fill",
        "lock.fill",
        "key.fill",
        "magnifyingglass",
        "plus.circle.fill",
        "checkmark.circle.fill",
        "xmark.circle.fill",
        "exclamationmark.triangle.fill",
        "info.circle.fill",
        "questionmark.circle.fill",
        "globe",
        "map.fill",
        "location.fill",
        "compass.drawing",
        "wallet.pass.fill",
        "creditcard.fill",
        "banknote.fill",
        "cart.fill",
        "bag.fill",
        "tshirt.fill",
        "shoe.fill",
        "eyeglasses",
        "ring.circle.fill",
        "speaker.wave.3.fill",
        "microphone.fill",
        "phone.fill",
        "message.fill",
        "envelope.fill",
        "paperplane.fill",
        "wifi",
        "antenna.radiowaves.left.and.right"
    ]

}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Kind.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var kindSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Habit")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            CustomSegmentedControl(
                selection: $kind,
                options: [
                    (value: Habit.Kind.good, icon: "hand.thumbsup.fill", text: String(localized: "Good"), color: .green),
                    (value: Habit.Kind.bad, icon: "hand.raised.fill", text: String(localized: "Bad"), color: .red)
                ]
            )
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Name.swift
import SwiftUI

extension Habit.Dashboard.Sheet {
    
    var nameSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Name")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField("Stretching", text: $name)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .focused($focusedField, equals: .habitName)
                .onSubmit {
                    Task {
                        try? await Task.sleep(for: .milliseconds(300))
                        advanceToNextField(from: .habitName)
                    }
                }
                .submitLabel(.next)
                .autocorrectionDisabled()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Target.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var targetSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Target")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField(String("6"), value: $targetValue, format: .number)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .keyboardType(.numberPad)
                .focused($focusedField, equals: .target)
                .onSubmit {
                    advanceToNextField()
                }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.Unit.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var unitSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Unit")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField("Sessions", text: $unit)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .focused($focusedField, equals: .habitUnit)
                .onSubmit {
                    Task {
                        try? await Task.sleep(for: .milliseconds(300))
                        advanceToNextField(from: .habitUnit)
                    }
                }
                .submitLabel(.next)
                .autocorrectionDisabled()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sheets/Dashboard.Sheet.Add.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    struct Add: View {

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.dismiss) private var dismiss
        @Environment(Habit.Dashboard.Manager.self) private var dashboardManager
        
        @FocusState var focusedField: Habit.Dashboard.Sheet.FocusedField?

        @State var habitName = ""
        @State var habitUnit = ""
        @State var selectedIcon = "star.fill"
        @State var selectedColor: Color = .blue
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var habitKind: Habit.Kind = .good
        
        let horizontalPadding: CGFloat = 16
        let columns = Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)

        var body: some View {
            NavigationStack {
                Habit.Dashboard.Sheet(
                    initial: .init(
                        name: "",
                        unit: "",
                        icon: "star.fill",
                        color: .blue,
                        target: nil,
                        kind: .good
                    ),
                    submitLabel: String(localized: "Add Habit"),
                    submitIcon: "plus",
                    onSubmit: { newHabit in
                        dashboardManager.addHabits([newHabit])
                        dismiss()
                    }
                )
                .toolbar { closeButtonToolbar }
                .presentationBackground {
                    Rectangle()
                        .fill(.thickMaterial)
                        .padding(.bottom, -100)
                }
                .presentationDetents([.large])
                .interactiveDismissDisabled()
                .navigationTitle("Add Habit")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
        
    }
    
}

extension Habit.Dashboard.Sheet.Add {

    private var isFormValid: Bool {
        !habitName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !habitUnit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        targetValue != nil && targetValue! > 0
    }

    private var closeButtonToolbar: some ToolbarContent {
        ToolbarItem(placement: .topBarTrailing) {
            Button(role: .cancel) {
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .tint(.red)
            .padding(.trailing, -8)
        }
    }

    private var addButton: some View {
        Button(role: .none) {
            addHabit()
        } label: {
            Label("Add Habit", systemImage: "plus")
                .fontWeight(.semibold)
        }
        .buttonStyle(.borderedProminent)
        .buttonBorderShape(.capsule)
        .tint(.blue)
        .disabled(!isFormValid)
    }
    
    private func addHabit() {
        guard isFormValid else { return }
        guard let targetValue else { return }
        
        let habit = Habit(
            name: habitName.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: habitUnit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: selectedIcon,
            color: selectedColor,
            target: targetValue,
            kind: habitKind
        )
        
        dashboardManager.addHabits([habit])
        dismiss()
    }

}
// ./Habit Rabbit/Screens/Dashboard/Views/Dashboard.Sheet/Sheets/Dashboard.Sheet.Edit.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    struct Edit: View {

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.dismiss) private var dismiss
        @Environment(Habit.Dashboard.Manager.self) private var dashboardManager
        
        let habit: Habit
        
        @FocusState var focusedField: Habit.Dashboard.Sheet.FocusedField?

        @State var habitName: String
        @State var habitUnit: String
        @State var selectedIcon: String
        @State var selectedColorIndex: Int
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var habitKind: Habit.Kind
        
        let horizontalPadding: CGFloat = 16
        let columns = Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)

        init(habit: Habit) {
            self.habit = habit
            self._habitName = State(initialValue: habit.name)
            self._habitUnit = State(initialValue: habit.unit)
            self._selectedIcon = State(initialValue: habit.icon)
            // Find the closest matching color index
            let colorIndex = Self.findClosestColorIndex(for: habit.color)
            self._selectedColorIndex = State(initialValue: colorIndex)
            self._targetValue = State(initialValue: habit.target)
            self._habitKind = State(initialValue: habit.kind)
        }

        var body: some View {
            NavigationStack {
                Habit.Dashboard.Sheet(
                    initial: .init(
                        name: habit.name,
                        unit: habit.unit,
                        icon: habit.icon,
                        color: habit.color,
                        target: habit.target,
                        kind: habit.kind
                    ),
                    submitLabel: "Update Habit",
                    submitIcon: "checkmark",
                    onSubmit: { newHabit in
                        dashboardManager.updateHabit(habit, with: newHabit)
                        dismiss()
                    }
                )
                .toolbar { closeButtonToolbar }
                .presentationBackground {
                    Rectangle()
                        .fill(.thickMaterial)
                        .padding(.bottom, -100)
                }
                .presentationDetents([.large])
                .interactiveDismissDisabled()
                .navigationTitle("Edit Habit")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
        
    }
    
}

extension Habit.Dashboard.Sheet.Edit {

    private var isFormValid: Bool {
        !habitName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !habitUnit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        targetValue != nil && targetValue! > 0
    }

    private var closeButtonToolbar: some ToolbarContent {
        ToolbarItem(placement: .topBarTrailing) {
            Button(role: .cancel) {
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .buttonStyle(.bordered)
            .buttonBorderShape(.circle)
            .tint(.red)
            .padding(.trailing, -8)
        }
    }

    private var updateButton: some View {
        Button(role: .none) {
            updateHabit()
        } label: {
            Label("Update Habit", systemImage: "checkmark")
                .fontWeight(.semibold)
        }
        .buttonStyle(.borderedProminent)
        .buttonBorderShape(.capsule)
        .tint(.blue)
        .disabled(!isFormValid)
    }
    
    private func updateHabit() {
        guard isFormValid else { return }
        guard let targetValue else { return }
        
        dashboardManager.updateHabit(
            habit,
            name: habitName.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: habitUnit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: selectedIcon,
            color: Habit.Dashboard.Sheet.availableColors[selectedColorIndex],
            target: targetValue,
            kind: habitKind
        )
        dismiss()
    }
    
    static func findClosestColorIndex(for color: Color) -> Int {
        // Convert the color to a comparable format and find the best match
        // For now, we'll use a simple approach by comparing against known colors
        let availableColors = Habit.Dashboard.Sheet.availableColors
        
        // Try to match by creating UIColors and comparing their components
        let targetUIColor = UIColor(color)
        var targetRed: CGFloat = 0, targetGreen: CGFloat = 0, targetBlue: CGFloat = 0, targetAlpha: CGFloat = 0
        targetUIColor.getRed(&targetRed, green: &targetGreen, blue: &targetBlue, alpha: &targetAlpha)
        
        var bestMatchIndex = 0
        var bestDistance = CGFloat.greatestFiniteMagnitude
        
        for (index, availableColor) in availableColors.enumerated() {
            let availableUIColor = UIColor(availableColor)
            var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
            availableUIColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
            
            // Calculate Euclidean distance in RGB space
            let distance = sqrt(
                pow(targetRed - red, 2) +
                pow(targetGreen - green, 2) +
                pow(targetBlue - blue, 2)
            )
            
            if distance < bestDistance {
                bestDistance = distance
                bestMatchIndex = index
            }
        }
        
        return bestMatchIndex
    }

}
// ./Habit Rabbit/Screens/DetailView/DetailView.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Card.DetailView {
    
    @Observable
    class Manager {

        private let habit: Habit
        private let modelContext: ModelContext
        
        private(set) var values: [Habit.Value] = []
        private(set) var isLoading = false
        private(set) var canLoadMore = false
        
        private let pageSize = 100
        private var currentOffset = 0
        
        init(for habit: Habit, using modelContext: ModelContext) {
            self.habit = habit
            self.modelContext = modelContext
            loadInitialValues()
        }
        
        var name: String { habit.name }
        var unit: String { habit.unit }
        var icon: String { habit.icon }
        var color: Color { habit.color }
        var target: Int { habit.target }
        var kind: Habit.Kind { habit.kind }
    
    }
    
}

extension Habit.Card.DetailView.Manager {
    
    func loadInitialValues() {
        loadValues(reset: true)
    }
    
    func loadMoreValues() {
        guard !isLoading && canLoadMore else { return }
        loadValues(reset: false)
    }
    
    private func loadValues(reset: Bool) {
        isLoading = true
        
        if reset {
            currentOffset = 0
            values = []
        }
        
        let habitID = habit.id
        
        let predicate = #Predicate<Habit.Value> {
            $0.habit?.persistentModelID == habitID
            && $0.currentValue > 0
        }
        
        let dateSort = SortDescriptor(\Habit.Value.date, order: .reverse)
        
        var descriptor = FetchDescriptor(predicate: predicate, sortBy: [dateSort])
        descriptor.fetchLimit = pageSize
        descriptor.fetchOffset = currentOffset
        descriptor.relationshipKeyPathsForPrefetching = [\Habit.Value.habit]
        
        do {
            let fetchedValues = try modelContext.fetch(descriptor)
            
            if reset {
                values = fetchedValues
            } else {
                values.append(contentsOf: fetchedValues)
            }
            
            currentOffset += fetchedValues.count
            canLoadMore = fetchedValues.count == pageSize
        } catch {
            canLoadMore = false
        }
        
        isLoading = false
    }
    
    func resetValue(_ value: Habit.Value) {
        value.currentValue = 0
        try? modelContext.save()
    }
    
    func updateValue(_ value: Habit.Value, to newValue: Int) {
        value.currentValue = newValue
        try? modelContext.save()
    }
    
}
// ./Habit Rabbit/Screens/DetailView/DetailView.swift
import SwiftUI
import SwiftData

extension Habit.Card {

    struct DetailView: View {

        @Environment(Habit.Card.Manager.self) private var cardManager
        @Environment(Habit.Dashboard.Manager.self) private var dashboardManager
        
        @State private var detailManager: Habit.Card.DetailView.Manager?
        @State private var editingValue: Habit.Value?
        @State private var editValueText: String = ""

        var body: some View {
            Group {
                if let detailManager {
                    valuesList
                        .environment(detailManager)
                        .safeAreaInset(edge: .bottom, spacing: 0) {
                            if detailManager.canLoadMore {
                                loadMoreButton
                            }
                        }
                        .contentMargins(.top, 16)
                } else {
                    loadingView
                }
            }
            .navigationTitle(cardManager.habit.name)
            .navigationBarTitleDisplayMode(.inline)
            .onAppear { setupDetailManager() }
            .alert("Edit Value", isPresented: .constant(editingValue != nil)) {
                editValueAlert
            } message: {
                editValueMessage
            }
        }

    }

}

extension Habit.Card.DetailView {

    private var valuesList: some View {
        List(detailManager?.values ?? []) { value in
            valueRow(for: value)
                .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                    swipeActions(for: value)
                }
        }
    }
    
    private func valueRow(for value: Habit.Value) -> some View {
        HStack {
            Text(verbatim: "\(value.date.formatted2)")
            Spacer()
            Text(verbatim: "\(value.currentValue)")
        }
    }

}

extension Habit.Card.DetailView {
    
    @ViewBuilder
    private func swipeActions(for value: Habit.Value) -> some View {
        Button {
            editingValue = value
            editValueText = "\(value.currentValue)"
        } label: {
            Label("Edit", systemImage: "pencil")
        }
        .tint(.blue)
        
        Button {
            detailManager?.resetValue(value)
        } label: {
            Label("Reset", systemImage: "trash")
        }
        .tint(.red)
    }
    
    @ViewBuilder
    private var editValueAlert: some View {
        TextField("Value", text: $editValueText)
            .keyboardType(.numberPad)
        Button("Cancel", action: cancelEdit)
        Button("Save", action: saveEdit)
    }
    
    @ViewBuilder
    private var editValueMessage: some View {
        if let value = editingValue {
            Text("Enter new value for \(value.date.formatted2)")
        }
    }
    
}

extension Habit.Card.DetailView {

    private var loadingView: some View {
        ProgressView()
            .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var loadMoreButton: some View {
        Button {
            detailManager?.loadMoreValues()
        } label: {
            HStack {
                if detailManager?.isLoading == true {
                    ProgressView()
                        .scaleEffect(0.8)
                } else {
                    Text("Load More Values")
                }
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
        }
        .disabled(detailManager?.isLoading == true)
        .padding(.horizontal)
        .padding(.bottom, 8)
    }

}

extension Habit.Card.DetailView {

    private func setupDetailManager() {
        if detailManager == nil {
            detailManager = Habit.Card.DetailView.Manager(
                for: cardManager.habit,
                using: dashboardManager.modelContext
            )
        }
    }

    private func cancelEdit() {
        editingValue = nil
        editValueText = ""
    }

    private func saveEdit() {
        if let value = editingValue,
           let newValue = Int(editValueText) {
            detailManager?.updateValue(value, to: newValue)
        }
        editingValue = nil
        editValueText = ""
    }

}
// ./Habit Rabbit/Views/AverageView/AverageColumn.swift
import SwiftUI

extension Habit.AverageView {

    struct AverageColumn: View {

        let title: String
        let value: Int
        let target: Int
        let unit: String
        let color: Color
        let kind: Habit.Kind
        let mode: Habit.Card.Mode

        var body: some View {
            VStack(spacing: 10) {
                Text(title)
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity)

                Habit.ProgressBar(
                    value: value,
                    target: target,
                    color: color,
                    axis: .vertical,
                    kind: kind,
                    mode: mode,
                    width: 50,
                    height: Habit.Card.Manager.contentHeight
                )
                .frame(maxHeight: .infinity)

                Habit.ProgressLabel(
                    value: value,
                    target: target,
                    unit: unit
                )                
            }
            .frame(maxWidth: .infinity)
        }

    }

}
// ./Habit Rabbit/Views/AverageView/AverageView.swift
import SwiftUI

extension Habit {

    struct AverageView: View {

        @Environment(Habit.Card.Manager.self) var cardManager
        @Environment(\.colorScheme) var colorScheme

        var body: some View {
            HStack(spacing: 16) {
                AverageColumn(
                    title: "Today",
                    value: cardManager.currentValue(for: .daily),
                    target: cardManager.currentTarget(for: .daily),
                    unit: cardManager.unit,
                    color: cardManager.color,
                    kind: cardManager.kind,
                    mode: .daily
                )
                AverageColumn(
                    title: "Week",
                    value: cardManager.currentValue(for: .weekly),
                    target: cardManager.currentTarget(for: .weekly),
                    unit: cardManager.unit,
                    color: cardManager.color,
                    kind: cardManager.kind,
                    mode: .weekly
                )
                AverageColumn(
                    title: "Month",
                    value: cardManager.currentValue(for: .monthly),
                    target: cardManager.currentTarget(for: .monthly),
                    unit: cardManager.unit,
                    color: cardManager.color,
                    kind: cardManager.kind,
                    mode: .monthly
                )
            }
            .frame(maxWidth: .infinity)
            .frame(height: 232)
            .padding(20)
            .background { Habit.Card.Background() }
        }

    }

}
// ./Habit Rabbit/Views/Background/Background.swift
import SwiftUI

extension EnvironmentValues {
    
    @Entry var showShadows: Bool? = nil
    
}

extension Habit.Card.Background {
    
    func showShadows(_ show: Bool) -> some View {
        self.environment(\.showShadows, show)
    }
    
}

extension Habit.Card {
    
    struct Background<B: View, S: InsettableShape>: View {
        
        @Environment(\.colorScheme) var colorScheme
        @Environment(\.showShadows) var showShadows
        
        private let extraBackground: B
        private let shape: S
        private let material: Material
        
        init(
            shape: S,
            material: Material = .regularMaterial,
            @ViewBuilder background: () -> B
        ) {
            self.shape = shape
            self.material = material
            self.extraBackground = background()
        }
        
        var body: some View {
            shape
                .fill(material)
                .strokeBorder(.quaternary, lineWidth: colorScheme == .dark ? 1 : 0.6)
                .background {
                    if showShadows ?? true {
                        shadowView
                    }
                    extraBackground
                }
        }
        
        private var shadowView: some View {
            ZStack {
                if colorScheme == .light {
                    shape
                        .fill(.black.opacity(0.09))
                        .blur(radius: 10)
                        .offset(x: 0, y: 4)
                    
                    shape
                        .fill(.black.opacity(0.05))
                        .blur(radius: 4)
                        .offset(x: 0, y: 2)
                }
            }
        }
        
    }
    
}

extension Habit.Card.Background where S == RoundedRectangle {
    
    init(@ViewBuilder background: () -> B) {
        self.init(
            shape: RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius),
            background: background
        )
    }
    
}

extension Habit.Card.Background where B == EmptyView, S == RoundedRectangle {
    
    init(shadow: Bool = true) {
        self.init(shape: RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius)) {
            EmptyView()
        }
    }
    
}

extension Habit.Card.Background where B == EmptyView {
    
    init(in shape: S, material: Material = .regularMaterial) {
        self.init(shape: shape, material: material) { EmptyView() }
    }
    
}
// ./Habit Rabbit/Views/Card/Card.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Card {
    
    @Observable
    class Manager {
        
        let habit: Habit
        let modelContext: ModelContext
        
        private let isMocked: Bool

        private(set) var lastDay: Date
        private(set) var mode: Habit.Card.Mode
        
        private var values: [Habit.Value] = []
        
        @ObservationIgnored 
        private var valueCache: [Date: Habit.Value] = [:]

        init(
            for habit: Habit,
            until lastDay: Date,
            mode: Habit.Card.Mode,
            using modelContext: ModelContext,
        ) {
            self.habit = habit
            self.mode = mode
            self.lastDay = lastDay
            self.modelContext = modelContext
            self.isMocked = false
            
            fetchValues()
        }

        init(mockFor habit: Habit) {
            let now = Date.now

            self.habit = habit
            self.mode = .daily
            self.lastDay = now
            self.modelContext = ModelContext(try! ModelContainer(for: Habit.self, Habit.Value.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true)))
            self.isMocked = true
            
            // Create a single mock value with half the target
            let mockValue = Habit.Value(
                habit: habit, 
                date: now, 
                currentValue: habit.target
            )
            self.values = [mockValue]
            self.valueCache = [Date(): mockValue]
        }
        
        var name: String { habit.name }
        var unit: String { habit.unit }
        var icon: String { habit.icon }
        var color: Color { habit.color }
        var target: Int { habit.target }
        var kind: Habit.Kind { habit.kind }
        
    }
    
}

extension Habit.Card.Manager {
    
    enum DayShift {
        case yesterday
        case tomorrow
    }
    
    func shiftLastDay(to direction: DayShift) {
        // add new value
        switch direction {
            case .yesterday: shiftToYesterday()
            case .tomorrow: shiftToTomorrow()
        }
    }
    
    func updateMode(to newMode: Habit.Card.Mode) {
        if mode != newMode { mode = newMode }
    }
    
}

extension Habit.Card.Manager {
    
    private func fetchOrCreateValue(for date: Date) -> Habit.Value {
        if isMocked {
            return values.first ?? Habit.Value(habit: habit, date: date, currentValue: habit.target)
        }
        
        if let cachedValue = valueCache[date] {
            return cachedValue
        }
        
        let descriptor = Habit.Value.filterBy(day: date, for: habit)
        let fetchedValue = (try? modelContext.fetch(descriptor))?.first
        ?? {
            let newValue = Habit.Value(habit: habit, date: date)
            modelContext.insert(newValue)
            return newValue
        }()
        
        valueCache[date] = fetchedValue
        return fetchedValue
    }
    
    private func fetchValues() {
        guard !isMocked else { return }
        // fetch core 30 day window for active values
        let coreDescription = Habit.Value.filterBy(days: 30, endingOn: lastDay, for: habit)
        guard let coreValues = try? modelContext.fetch(coreDescription) else { return }
        values = coreValues
        
        // fetch extended window: additional 14 days in past and future for cache pre-loading
        let pastEnd = lastDay.shift(days: -30) // day before the 30-day window starts
        let pastDescription = Habit.Value.filterBy(days: 14, endingOn: pastEnd, for: habit)
        let pastValues = (try? modelContext.fetch(pastDescription)) ?? []
        
        let futureStart = lastDay.tomorrow
        let futureEnd = futureStart.shift(days: 14)
        let futureDescription = Habit.Value.filterBy(days: 14, endingOn: futureEnd, for: habit)
        let futureValues = (try? modelContext.fetch(futureDescription)) ?? []
        
        // populate cache with all fetched values (core + extended)
        for value in coreValues + pastValues + futureValues {
            valueCache[value.date] = value
        }
        
        // create lookup dictionary for efficient date checking
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        // abort if lastDay already exists
        guard existingValues[lastDay] == nil else { return }
        
        // create and save lastDay value
        let lastDayValue = Habit.Value(habit: self.habit, date: lastDay)
        modelContext.insert(lastDayValue)
        values.append(lastDayValue)
        valueCache[lastDay] = lastDayValue
    }
    
    private func shiftToYesterday() {
        // 1. Get the value for the new lastDay (yesterday)
        let newLastDay = lastDay.yesterday
        let newLastDayValue = fetchOrCreateValue(for: newLastDay)

        // 2. Create lookup dictionary for efficient operations
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        // 3. Cache values that are being removed from active window but keep them in cache
        let oldLastDay = self.lastDay
        if let removedValue = existingValues[oldLastDay] {
            valueCache[oldLastDay] = removedValue
        }
        
        // 4. Remove the OLD lastDay's value and build new values array
        var newValues = values.filter { !$0.date.isSameDay(as: oldLastDay) && !$0.date.isSameDay(as: newLastDay) }

        // 5. Insert the new oldest day's value (only if not already present)
        let newOldestDay = newLastDay.shift(days: -29)
        if existingValues[newOldestDay] == nil {
            let newOldestValue = fetchOrCreateValue(for: newOldestDay)
            newValues.insert(newOldestValue, at: 0)
        }

        // 6. Update lastDay and ensure its value is at the end
        lastDay = newLastDay
        newValues.append(newLastDayValue)
        values = newValues
        
        // 7. Cleanup cache periodically
        cleanupCache()
    }
    
    private func shiftToTomorrow() {
        // 1. Get the value for the new lastDay (tomorrow)
        let newLastDay = lastDay.tomorrow
        let newLastDayValue = fetchOrCreateValue(for: newLastDay)
        
        // 2. Calculate which day is no longer in the 30-day window
        let oldestDayToRemove = newLastDay.shift(days: -30)
        
        // 3. Cache values that are being removed from active window
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        if let removedValue = existingValues[oldestDayToRemove] {
            valueCache[oldestDayToRemove] = removedValue
        }
        
        // 4. Filter out the oldest day and any existing entry for newLastDay
        values = values.filter { !$0.date.isSameDay(as: oldestDayToRemove) && !$0.date.isSameDay(as: newLastDay) }
        
        // 5. Update lastDay and append new value
        lastDay = newLastDay
        values.append(newLastDayValue)
        
        // 6. Cleanup cache periodically
        cleanupCache()
    }
    
    private func cleanupCache() {
        // Keep cache size reasonable by maintaining a window around lastDay (30 days in each direction)
        let pastCutoff = lastDay.shift(days: -30)
        let futureCutoff = lastDay.shift(days: 30)
        
        valueCache = valueCache.filter { date, _ in
            (pastCutoff...futureCutoff).contains(date)
        }
    }
    
}

extension Habit.Card.Manager {
    
    func resetDailyValue() {
        dailyValue?.currentValue = 0
    }
    
    func randomizeDailyValue() {
        dailyValue?.currentValue = Int.random(in: 0...habit.target * 2)
    }
    
    func randomizeName() {
        habit.name = "Test \(Int.random(in: 1...1000))"        
    }
    
    func randomizeMonthlyValues() {
        // create new values array
        var newValues: [Habit.Value] = []
        // create lookup of existing values
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { first, _ in first })

        // randomize values for the last 30 days
        for dayOffset in (0..<30).reversed() {
            let day = lastDay.shift(days: -dayOffset)
            let randomValue = Int.random(in: 0...habit.target * 2)
                        
            if let existingValue = existingValues[day] {
                // update existing value
                existingValue.currentValue = randomValue
                newValues.append(existingValue)
            } else {
                // create missing value
                let value = Habit.Value(habit: habit, date: day, currentValue: randomValue)
                modelContext.insert(value)
                newValues.append(value)
            }
        }
        
        // update with randomized values
        values = newValues
        
        // update cache with all randomized values
        for value in newValues {
            valueCache[value.date] = value
        }
    }
    
}

extension Habit.Card.Manager {
    
    var dailyValue: Habit.Value? { values.last }
    
    var weeklyValues: [Habit.Value] {
        let firstDay = lastDay.shift(days: -6)
        let allDays = (0..<7).map {
            firstDay.shift(days: $0)
        }
        
        let lookup = Dictionary(values.suffix(7).map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        return allDays.map { day in
            lookup[day] ?? Habit.Value(habit: habit, date: day, currentValue: 0)
        }
    }
    
    struct DayCell {
        let date: Date
        let value: Habit.Value?
    }
    
    var monthlyValues: [[DayCell]] {
        let firstDay = lastDay.shift(days: -29)
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        let gridLastWeekFirstDay = Calendar.current.dateInterval(of: .weekOfYear, for: lastDay)!.start
        let gridLastDay = gridLastWeekFirstDay.shift(days: 6)
        let gridFirstDay = gridLastDay.shift(days: -41)

        let cells = (0..<42).map { offset in
            let day = gridFirstDay.shift(days: offset)

            let value = (firstDay...lastDay).contains(day)
                ? existingValues[day] ?? Habit.Value(habit: habit, date: day, currentValue: 0)
                : nil

            return DayCell(date: day, value: value)
        }
    
        let allRows = stride(from: 0, to: cells.count, by: 7).map { startIndex in
            Array(cells[startIndex..<min(startIndex + 7, cells.count)])
        }
        
        // Only show first row when lastDay is at the start of the week (Monday)
        let lastDayWeekdayIndex = Calendar.current.weekdayIndex(for: lastDay)
        let shouldShowFirstRow = lastDayWeekdayIndex == 0
        
        return shouldShowFirstRow ? allRows : Array(allRows.dropFirst())
    }
    
}

extension Habit.Card.Manager {
    
    func currentValue(for mode: Habit.Card.Mode? = nil) -> Int {
        switch mode ?? self.mode {
            case .daily: dailyValue?.currentValue ?? 0
            case .weekly: weeklyValues.reduce(0) { $0 + $1.currentValue }
            case .monthly: values.reduce(0) { $0 + $1.currentValue }
        }
    }
    
    func currentTarget(for mode: Habit.Card.Mode? = nil) -> Int {
        switch mode ?? self.mode {
            case .daily: habit.target
            case .weekly: habit.target * 7
            case .monthly: habit.target * 30
        }
    }
    
    func isCompleted(for mode: Habit.Card.Mode? = nil) -> Bool {
        switch kind {
            case .good: currentValue(for: mode) >= currentTarget(for: mode)
            case .bad: currentValue(for: mode) < currentTarget(for: mode)
        }
    }
    
}

extension Habit.Card.Manager {
    
    static let cardHeight: CGFloat = 232
    static let cornerRadius: CGFloat = 24
    static let contentHeight: CGFloat = 155
    static let cubesGridHeight: CGFloat = 126 // 6 rows: 6 * 16 (cube) + 5 * 6 (spacing) = 126
    
    var labelBottomPadding: CGFloat {
        switch mode {
            case .daily: 20
            case .weekly: 10
            case .monthly: 14
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Card.Mode.swift
import SwiftUI

extension Habit.Card {
    
    enum Mode: CaseIterable {
        case daily
        case weekly
        case monthly
        
        var localizedTitle: LocalizedStringKey {
            switch self {
                case .daily: "Daily"
                case .weekly: "Weekly"
                case .monthly: "Monthly"
            }
        }
    }
    
    func cardMode(_ mode: Habit.Card.Mode) -> some View {
        self.environment(\.cardMode, mode)
    }
    
}

extension EnvironmentValues {
    
    @Entry var cardMode: Habit.Card.Mode? = nil
    
}
// ./Habit Rabbit/Views/Card/Card.swift
import SwiftUI
import SwiftData

extension Habit {

    struct Card: View {
        
        @Namespace var modeTransition

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.cardMode) var cardMode
        @Environment(\.cardOffset) var cardOffset
        
        @Environment(Card.Manager.self) var cardManager
        @Environment(Dashboard.Manager.self) var dashboardManager
        
        var onEdit: ((Habit) -> Void)?
        
        var mode: Habit.Card.Mode { cardMode ?? cardManager.mode }
        
        @State var isDeleting = false
        
        var body: some View {
            VStack(spacing: 0) {
                Group {
                    switch mode {
                        case .daily: dailyView
                        case .weekly: weeklyView
                        case .monthly: monthlyView
                    }
                }
                .transition(.blurReplace)
                
                habitLabel
            }
            .animation(.spring(duration: 0.62), value: mode)
            .animation(.spring(duration: 0.62), value: cardManager.lastDay)
            .frame(maxWidth: .infinity)
            .frame(height: Card.Manager.cardHeight)
            .clipShape(.rect(cornerRadius: Card.Manager.cornerRadius))
            .background { Habit.Card.Background { colorEffect }.showShadows(false) }
            .geometryGroup()
            .scaleEffect(isDeleting ? 0 : 1)
            .contentShape(.contextMenuPreview, .rect(cornerRadius: Manager.cornerRadius))
            .contextMenu { contextMenuButtons }
            .offset(isDeleting ? deleteOffset : .zero)
            .compositingGroup()
        }
        
    }
    
}

extension Habit.Card {
    
    var habitLabel: some View {
        VStack(spacing: mode == .monthly ? 4 : 2) {
            Label(String("\(cardManager.name)"), systemImage: cardManager.icon)
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.primary)
                .lineLimit(1)
            
            if mode != .daily {
                (
                    Text(verbatim: "\(cardManager.currentValue(for: mode))")
                        .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                    +
                    Text(verbatim: " / ")
                        .foregroundStyle(.primary.opacity(0.6))
                    +
                    Text(verbatim: "\(cardManager.currentTarget(for: mode))")
                        .foregroundStyle(.primary.opacity(0.6))
                )
                .font(.subheadline)
                .fontWeight(.semibold)
                .monospacedDigit()
                .contentTransition(.numericText())
            }
        }
        .frame(maxHeight: .infinity, alignment: .bottom)
        .padding(.bottom, cardManager.labelBottomPadding)
    }
    
    var colorEffect: some View {
        Rectangle()
            .fill(cardManager.color.gradient)
            .opacity(cardManager.isCompleted(for: mode) ? (colorScheme == .dark ? 0.5 : 0.7) : 0)
            .offset(x: 0, y: 180)
            .clipShape(.rect(cornerRadius: Manager.cornerRadius))
            .animation(.bouncy, value: cardManager.isCompleted(for: mode))
    }
    
    @ViewBuilder
    static func shadowEffect(_ colorScheme: ColorScheme) -> some View {
        if colorScheme == .light {
            RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius)
                .fill(.black.opacity(0.09))
                .blur(radius: 10)
                .offset(x: 0, y: 4)
            
            RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius)
                .fill(.black.opacity(0.05))
                .blur(radius: 4)
                .offset(x: 0, y: 2)
        }
    }
    
}

extension EnvironmentValues {
    
    @Entry var cardOffset: Int = 0
    
}

extension Habit.Card {
    
    func deleteWithAnimation() {
        Task {
            try? await Task.sleep(nanoseconds: 10_000_000)
            withAnimation(.spring(duration: 0.8)) {
                isDeleting = true
            }
            
            try? await Task.sleep(nanoseconds: 10_000_000)
            cardManager.modelContext.delete(cardManager.habit)
            
            dashboardManager.refreshCardManagers()
        }
    }
    
    var deleteOffset: CGSize {
        let offset = (cardOffset % 2 == 0) ? -250 : 250
        return CGSize(width: CGFloat(offset), height: 100)
    }
    
}

extension Habit.Card {
    
    @ViewBuilder
    var contextMenuButtons: some View {
        if let onEdit {
            Button("Edit", systemImage: "pencil") {
                onEdit(cardManager.habit)
            }
        }
        #if DEBUG
        Button("Randomize", systemImage: "sparkles") {
            cardManager.randomizeDailyValue()
        }
        Button("Randomize Name", systemImage: "characters.uppercase") {
            cardManager.randomizeName()
        }
        Button("Reset", systemImage: "arrow.counterclockwise") {
            cardManager.dailyValue?.currentValue = 0
        }
        #endif
        Button("Delete", systemImage: "trash", role: .destructive) {
            deleteWithAnimation()
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Views/dailyView.swift
import SwiftUI

extension Habit.Card {
    
    var dailyView: some View {
        HStack(spacing: 0) {
            Habit.ProgressBar(
                value: cardManager.currentValue(for: mode),
                target: cardManager.target,
                color: cardManager.color,
                axis: .vertical,
                kind: cardManager.kind,
                mode: cardManager.mode,
                width: 50,
                height: Habit.Card.Manager.contentHeight
            )
            .matchedGeometryEffect(id: "progress\(cardManager.dailyValue?.date ?? cardManager.lastDay)", in: modeTransition, anchor: .topLeading)
            
            Spacer(minLength: 12)
            
            VStack(spacing: 0) {
                Habit.ProgressLabel(
                    value: cardManager.currentValue(for: mode),
                    target: cardManager.habit.target,
                    unit: cardManager.unit
                )
                .animation(.bouncy, value: cardManager.currentValue(for: mode))
                .frame(maxHeight: .infinity)
                
                Habit.ProgressButton()
                    .frame(width: 70, height: 70)
            }
        }
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.horizontal, 20)
        .padding(.top, 20)
    }
    
}


// ./Habit Rabbit/Views/Card/Views/monthlyView.swift
import SwiftUI

extension Habit.Card {

    var monthlyView: some View {
        VStack(spacing: 6) {
            HStack(spacing: 6) {
                ForEach(dashboardManager.weekdaySymbols.enumerated, id: \.offset) { index, symbol in
                    Habit.WeekdaySymbol(
                        symbol: symbol,
                        color: weekdaySymbolStyle(for: index)
                    )
                    .frame(width: 16, height: 16)
                }
            }
            .padding(.top, 4)
            .padding(.bottom, 2)
            
            VStack(spacing: 6) {
                ForEach(cardManager.monthlyValues, id: \.first?.date) { weekValues in
                    HStack(spacing: 6) {
                        ForEach(weekValues, id: \.date) { cell in                        
                            RoundedRectangle(cornerRadius: 4)
                                .fill(cubeColor(for: cell.value))
                                .strokeBorder(.tertiary, lineWidth: cubeStrokeWidth(for: cell.value))
                                .brightness(cubeBrightness(for: cell.value))
                                .frame(width: 16, height: 16)
                                .opacity(cell.value == nil ? 0 : 1)
                                .matchedGeometryEffect(id: "progress\(cell.date)", in: modeTransition)
                                .animation(.bouncy, value: cell.value?.currentValue)
                        }
                    }
                    .compositingGroup()
                    .geometryGroup()
                }
            }
            .frame(height: Habit.Card.Manager.cubesGridHeight)
            .frame(maxWidth: .infinity)
            .clipped()
        }
        .geometryGroup()
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.top, 10)
    }
    
}

extension Habit.Card {
    
    private func weekdaySymbolStyle(for index: Int) -> Color {
        .primary.opacity(index == dashboardManager.lastDayIndex ? 0.8 : 0.4)
    }

}

extension Habit.Card {
    
    func cubeColor(for value: Habit.Value?) -> AnyShapeStyle {
        guard let value else {
            if cardManager.kind == .good {
                return AnyShapeStyle(.quaternary)
            } else {
                return AnyShapeStyle(cardManager.color)
            }
        }
        
        let meetsTarget = cardManager.habit.kind == .good
        ? value.currentValue >= cardManager.habit.target
        : value.currentValue < cardManager.habit.target
        
        return meetsTarget ? AnyShapeStyle(cardManager.color) : AnyShapeStyle(.quaternary)
    }
    
    func cubeBrightness(for value: Habit.Value?) -> Double {
        guard let value else { return 0 }
        let isDark = colorScheme == .dark
        let exceedsTarget = value.currentValue > cardManager.habit.target
        let meetsTarget = value.currentValue == cardManager.habit.target
        
        return switch (cardManager.habit.kind, isDark, exceedsTarget, meetsTarget) {
            case (.good, true, true, _)   :  0.1   // exceeding good habit in dark mode: brighter
            case (.good, true, false, _)  : -0.1   // not exceeding good habit in dark mode: darker
            case (.good, false, true, _)  : -0.1   // exceeding good habit in light mode: darker
            case (.good, false, false, _) :  0.1   // not exceeding good habit target in light mode: brighter
            case (.bad, _, false, false)  :  0     // below bad habit: no adjustment
            case (.bad, _, false, true)   :  0.2   // meeting bad habit: brighter
            case (.bad, true, true, _)    : -0.6   // exceeding bad habit in dark mode: much darker
            case (.bad, false, true, _)   : -0.8   // exceeding bad habit in light mode: darker
        }
    }
    
    func cubeStrokeWidth(for value: Habit.Value?) -> Double {
        guard let value else { return 0 }
        let isDark = colorScheme == .dark
        let exceedsTarget = value.currentValue > cardManager.habit.target
        
        return switch (cardManager.habit.kind, isDark, exceedsTarget) {
            case (.bad, true, true)  :  0.75  // exceeding bad habit in dark mode: medium stroke
            default                  :  0     // no stroke
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Views/weeklyView.swift
import SwiftUI

extension Habit.Card {
    
    var weeklyView: some View {
        VStack(alignment: .leading, spacing: 9) {
            ForEach(cardManager.weeklyValues.enumerated, id: \.element.id) { index, value in
                HStack(spacing: 12) {
                    Habit.WeekdaySymbol(
                        symbol: dashboardManager.weekdaySymbol(for: value.date),
                        color: .primary.opacity(index == 6 ? 0.8 : 0.4)
                    )
                    .frame(width: 10, height: 13)
                    
                    Habit.ProgressBar(
                        value: value.currentValue,
                        target: cardManager.habit.target,
                        color: cardManager.color,
                        axis: .horizontal,
                        kind: cardManager.habit.kind,
                        mode: cardManager.mode,
                        width: 118,
                        height: 13,
                    )
                    .matchedGeometryEffect(id: "progress\(value.date)", in: modeTransition, anchor: .leading)
                }
                .compositingGroup()
                .geometryGroup()
                .frame(maxWidth: .infinity)
            }
        }
        .geometryGroup()
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.top, 18)
        .padding(.trailing, 4)
    }
    
}
// ./Habit Rabbit/Views/CustomSegmentedControl/CustomSegmentedControl.swift
import SwiftUI

struct CustomSegmentedControl<T: Hashable>: View {

    @Binding var selection: T
    let options: [(value: T, icon: String, text: String, color: Color)]
    
    @State private var selectedIndex: Int = 0
    
    private var selectedOptionColor: Color {
        guard let index = options.firstIndex(where: { $0.value == selection }) else { return .blue }
        return options[index].color
    }
    
    var body: some View {
        GeometryReader { geometry in
            let segmentWidth = geometry.size.width / CGFloat(options.count)
            
            ZStack {
                // Background
                RoundedRectangle(cornerRadius: 10)
                    .fill(.quaternary)
                
                // Moving selected background
                RoundedRectangle(cornerRadius: 10)
                    .fill(selectedOptionColor)
                    .frame(width: segmentWidth - 4, height: geometry.size.height - 4)
                    .offset(x: CGFloat(selectedIndex) * segmentWidth - geometry.size.width / 2 + segmentWidth / 2)
                
                // Segment buttons
                HStack(spacing: 0) {
                    ForEach(options.enumerated, id: \.offset) { index, option in
                        Button {
                            withAnimation {
                                selection = option.value
                                selectedIndex = index
                            }
                        } label: {
                            HStack(spacing: 6) {
                                Image(systemName: option.icon)
                                    .font(.system(size: 16, weight: .semibold))
                                Text(option.text)
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .foregroundColor(selection == option.value ? .white : .secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .contentShape(.rect)
                        }
                        .buttonStyle(.plain)
                    }
                }
            }
        }
        .frame(height: 44)
        .padding(2)
        .onAppear {
            if let index = options.firstIndex(where: { $0.value == selection }) {
                selectedIndex = index
            }
        }
        .onChange(of: selection) { _, newValue in
            if let index = options.firstIndex(where: { $0.value == newValue }) {
                selectedIndex = index
            }
        }
    }
    
}
// ./Habit Rabbit/Views/ModePicker/ModePicker.swift
import SwiftUI

extension Habit.Dashboard {
    
    struct ModePicker: View {
        
        let width: CGFloat
        let mode: Habit.Card.Mode
        let onSelection: (Habit.Card.Mode) -> Void
        
        var body: some View {
            HStack(spacing: 0) {
                ForEach(Habit.Card.Mode.allCases, id: \.self) { item in
                    Button {
                        let newMode = mode == item ? mode.next : item
                        onSelection(newMode)
                    } label: {
                        Text(item.localizedTitle)
                            .font(.system(size: 14, weight: .medium))
                            .foregroundStyle(mode == item ? .primary : .secondary)
                            .fontWeight(mode == item ? .bold : .medium)
                    }
                    .buttonStyle(.plain)
                    .contentShape(.rect)
                    .frame(width: width / 3)
                    .padding(.vertical, 6)
                }
            }
            .frame(width: width)
            .background {
                selectedIndicator
            }
        }
        
        private var selectedIndicator: some View {
            Habit.Card.Background(in: .capsule)
                .showShadows(false)
                .frame(width: width / 3)
                .frame(maxWidth: .infinity, alignment: .leading)
                .offset(
                    x: CGFloat(Habit.Card.Mode.allCases.firstIndex(of: mode) ?? 0) * (width / 3),
                    y: 0
                )
                .animation(.spring(duration: 0.62), value: mode)
        }
    }
    
}
// ./Habit Rabbit/Views/ProgressBar/ProgressBar.swift
import SwiftUI

extension Habit {
    
    struct ProgressBar: View {
        
        @Environment(\.colorScheme) var colorScheme
        
        let value: Int
        let target: Int
        let color: Color
        let axis: Axis
        let kind: Habit.Kind
        let mode: Habit.Card.Mode
        let width: CGFloat
        let height: CGFloat
        
        private let inset: CGFloat = 3
        
        var body: some View {
            Capsule()
                .fill(.quaternary)
                .strokeBorder(.quaternary, lineWidth: trackStrokeWidth)
                .brightness(trackBrightness)
                .overlay {
                    Capsule()
                        .fill(color.gradient)
                        .brightness(colorBrightness)
                        .offset(
                            x: axis == .horizontal ? offset : 0,
                            y: axis == .vertical ? offset : 0
                        )
                        .shadow(color: .black.opacity(0.07), radius: 2, x: 0, y: -2)
                        .clipShape(.capsule)
                        .padding(axis == .vertical ? inset : 0)
                }
                .geometryGroup()
                .frame(width: width, height: height)
                .fixedSize()
                .animation(.bouncy, value: value)
        }
    }
    
}

// MARK: - Geometry
extension Habit.ProgressBar {
    
    private var progress: CGFloat {
        guard target > 0 else { return 0 }
        return CGFloat(value) / CGFloat(target)
    }
    
    private var offset: CGFloat {
        let dimension = axis == .vertical ? height : width
        
        let base = switch (kind, axis) {
            case (.good, .vertical)   :  dimension - inset * 2    // fills upward
            case (.good, .horizontal) : -dimension                // fills rightward
            case (.bad, .vertical)    :  dimension - inset * 2    // depletes downward
            case (.bad, .horizontal)  : -dimension                // depletes leftward
        }
        
        return switch kind {
            case .good:
                switch progress {
                    case  ...0: base
                    case 0..<1: base * (1 - compensate(progress))
                    case  1...: 0
                    default   : base
                }
            case .bad:
                switch progress {
                    case  ...0: 0
                    case 0..<1: base * (1 - compensate(1 - progress))
                    case  1...: base
                    default   : 0
                }
        }
    }
    
}

extension Habit.ProgressBar {
    
    // boosts mid-range values to compensate the visual shortening from rounded capsule caps
    private func compensate(_ progress: CGFloat) -> CGFloat {
        let clamped = max(0, min(1, progress))
        let lift = min(0.06, 0.04 + 0.6 * curvature)
        let bump = clamped * (1 - clamped)
        let power: CGFloat = 2
        let peak = pow(0.25, power)
        let scale = lift / peak
        let boost = scale * pow(bump, power)
        return max(0, min(1, clamped + boost))
    }
    
    // bar thickness relative to its usable track length
    private var curvature: CGFloat {
        let isVertical = axis == .vertical
        let thickness = isVertical ? width : height
        let length = isVertical ? height : width
        let inset = isVertical ? inset : 0
        let track = max(1, length - inset * 2)
        return min(1, thickness / track)
    }
    
}

// MARK: - Style
extension Habit.ProgressBar {
    
    var colorBrightness: Double {
        switch (kind, isDark, exceedsTarget) {
            case (.bad, _, _)          :  0     // bad habit: no adjustment
            case (.good, true, true)   :  0.1   // exceeding good habit in dark mode: brighter color
            case (.good, true, false)  : -0.1   // non-exceeding good habit in dark mode: darker color
            case (.good, false, true)  : -0.1   // exceeding good habit in light mode: darker color
            case (.good, false, false) :  0.1   // non-exceeding good habit in light mode: brighter color
        }
    }
    
    var trackBrightness: Double {
        switch (kind, isDark, exceedsTarget) {
            case (.good, _, _)       :  0.2   // good habits: no adjustment
            case (.bad, _, false)    :  0.2   // non-exceeding bad habit in dark mode: no adjustment
            case (.bad, true, true)  : -0.6   // exceeding bad habit in dark mode: much darker
            case (.bad, false, true) : -0.5   // exceeding bad habit in light mode: darker
        }
    }
    
    var trackStrokeWidth: Double {
        switch (kind, isDark, exceedsTarget, isDaily) {
            case (.good, _, _, _)          :  0     // good habits: no stroke
            case (.bad, _, false, _)       :  0     // non-exceeding bad habit: no stroke
            case (.bad, false, true, _)    :  0     // exceeding bad habit in light mode: no stroke
            case (.bad, true, true, true)  :  1.5   // exceeding bad habit in daily dark mode: thick stroke
            case (.bad, true, true, false) :  0.75  // exceeding bad habit in other dark mode: medium stroke
        }
    }
    
    private var isDark: Bool { colorScheme == .dark }
    
    private var isDaily: Bool { mode == .daily }
    
    private var exceedsTarget: Bool { value > target }
    
}
// ./Habit Rabbit/Views/ProgressButton/ProgressButton.swift
import SwiftUI

extension Habit {
    
    struct ProgressButton: View {
        
        @Environment(\.colorScheme) private var colorScheme
        @Environment(\.cardMode) var cardMode
        
        @Environment(Habit.Card.Manager.self) private var cardManager
        
        var mode: Habit.Card.Mode {
            cardMode ?? cardManager.mode
        }
        
        var body: some View {
            Button {
                cardManager.dailyValue?.currentValue += 1
            } label: {
                ZStack {
                    Circle()
                        .fill(.quaternary)
                    Circle()
                        .fill(cardManager.color.gradient)
                        .brightness(buttonBrightness)
                        .clipShape(.capsule)
                        .padding(3)
                        .animation(.default, value: buttonBrightness)
                    
                    Image(systemName: "plus")
                        .font(.title)
                        .fontWeight(.medium)
                        .foregroundStyle(.white)
                }
            }
            .buttonStyle(.plain)
            .sensoryFeedback(.increase, trigger: cardManager.dailyValue?.currentValue)
        }
        
    }
    
}

extension Habit.ProgressButton {
    
    var buttonBrightness: Double {
        if cardManager.habit.kind == .good {
            return cardManager.currentValue(for: mode) > cardManager.habit.target ? (colorScheme == .dark ? 0.1 : -0.1) : (colorScheme == .dark ? -0.1 : 0.1)
        } else {
            return 0
        }
    }
    
}
// ./Habit Rabbit/Views/ProgressLabel/ProgressLabel.swift
import SwiftUI

extension Habit {

    struct ProgressLabel: View {

        @Environment(\.colorScheme) var colorScheme

        let value: Int
        let target: Int
        let unit: String

        var body: some View {
            VStack(spacing: 2) {
                VStack {
                    (
                        Text(verbatim: "\(value)")
                            .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                        +
                        Text(verbatim: " / ")
                            .foregroundStyle(.primary.opacity(0.6))
                        +
                        Text(verbatim: "\(target)")
                            .foregroundStyle(.primary.opacity(0.6))
                    )
                    .font(.title2)
                    .fontWeight(.semibold)
                    .monospacedDigit()
                    .contentTransition(.numericText())
                }
                Text(verbatim: unit.pluralized(count: target))
                    .font(.footnote)
                    .fontWeight(.medium)
                    .foregroundStyle(.secondary)
            }
            .frame(maxWidth: .infinity)
            .minimumScaleFactor(0.7)
            .lineLimit(1)
            .padding(.horizontal, 2)
        }

    }
    
}
// ./Habit Rabbit/Views/WeekdaySymbol/WeekdaySymbol.swift
import SwiftUI

extension Habit {
    
    struct WeekdaySymbol: View {
        
        let symbol: String
        let color: Color
        
        var body: some View {
            Text(symbol)
                .font(.caption2)
                .fontWeight(.medium)
                .foregroundStyle(color)
                .lineLimit(1)
        }
        
    }
    
}
