// ./Habit Rabbit/App/HabitRabbit.swift
import SwiftUI
import SwiftData

@main
struct HabitRabbit: App {
    
    let modelContainer: ModelContainer
    let dashboardManager: Habit.Dashboard.Manager 
    
    init() {
        modelContainer = try! ModelContainer(for: Habit.self, Habit.Value.self)
        dashboardManager = Habit.Dashboard.Manager(using: modelContainer.mainContext)
        
        let appearance = UISegmentedControl.appearance()
        appearance.setTitleTextAttributes([
            .font: UIFont.boldSystemFont(ofSize: 14)
        ], for: .selected)
        
        appearance.setTitleTextAttributes([
            .font: UIFont.boldSystemFont(ofSize: 14)
        ], for: .normal)
    }
    
    var body: some Scene {
        WindowGroup {
            Habit.Dashboard()
                .environment(dashboardManager)
        }
    }
    
}

@MainActor
var habitRabitPreview: some View {
    let modelContainer = try! ModelContainer(for: Habit.self, Habit.Value.self)
    let dashboardManager = Habit.Dashboard.Manager(using: modelContainer.mainContext)
    
    return Habit.Dashboard()
        .environment(dashboardManager)
        .modelContainer(modelContainer)
}

#Preview { habitRabitPreview }
// ./Habit Rabbit/App/Extensions/Calendar.swift
import SwiftUI

extension Calendar {
    
    var weekdaySymbols: [String] {
        let formatter = DateFormatter()
        formatter.locale = Locale.preferred
        guard let symbols = formatter.veryShortWeekdaySymbols, !symbols.isEmpty else { return [] }
        let first = (firstWeekday - 1) % symbols.count
        let rotated = Array(symbols[first...] + symbols[..<first])
        return rotated
    }
    
    // compute zero-based weekday column index aligned to calendar.firstWeekday
    func weekdayIndex(for date: Date) -> Int {
        // get 1-based weekday component for the given date
        let weekday = component(.weekday, from: date)
        // normalize to zero-based index relative to firstWeekday
        return (weekday - firstWeekday + 7) % 7
    }
    
}
// ./Habit Rabbit/App/Extensions/Collections.swift
import SwiftUI

extension CaseIterable where Self: Equatable, AllCases: BidirectionalCollection {
    
    var next: Self {
        let all = Self.allCases
        let current = all.firstIndex(of: self)!
        let next = all.index(after: current)
        return all[next == all.endIndex ? all.startIndex : next]
    }
    
    var previous: Self {
        let all = Self.allCases
        let current = all.firstIndex(of: self)!
        let previous = current == all.startIndex ? all.index(before: all.endIndex) : all.index(before: current)
        return all[previous]
    }
    
    var isFirst: Bool {
        Self.allCases.first == self
    }
    
    var isLast: Bool {
        Self.allCases.last == self
    }
    
}

extension RandomAccessCollection {

    var enumerated: [(offset: Int, element: Element)] {
        Array(self.enumerated())
    }
    
}
// ./Habit Rabbit/App/Extensions/Date.swift
import SwiftUI

extension Date {
    
    var tomorrow: Date {
        Calendar.current.date(byAdding: .day, value: 1, to: self)!
    }
    
    var yesterday: Date {
        Calendar.current.date(byAdding: .day, value: -1, to: self)!
    }
    
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }

    func shift(days dayOffset: Int) -> Date {
        Calendar.current.date(byAdding: .day, value: dayOffset, to: self)!
    }
    
    func isSameDay(as other: Date) -> Bool {
        Calendar.current.isDate(self, inSameDayAs: other)
    }
    
}

extension Date {
    
    enum Format {
        case date
        case dateWeekday
        case weekdayDate
        case debug
    }
    
    func formatted(_ style: Format) -> String {
        let formatter = DateFormatter()
        formatter.locale = Locale.preferred
        
        switch style {
            case .date:
                formatter.setLocalizedDateFormatFromTemplate("ddMMyyyy")
                return formatter.string(from: self)
                
            case .dateWeekday:
                formatter.setLocalizedDateFormatFromTemplate("ddMMyyyy")
                let datePart = formatter.string(from: self)
                formatter.setLocalizedDateFormatFromTemplate("EEEE")
                let weekdayPart = formatter.string(from: self)
                return "\(datePart), \(weekdayPart)"
                
            case .weekdayDate:
                formatter.setLocalizedDateFormatFromTemplate("ddMMyyyyEEEE")
                return formatter.string(from: self)
                
            case .debug:
                formatter.dateFormat = "EEEE, dd.MM.yyyy, HH:mm:ss"
                return formatter.string(from: self)
        }
    }
    
}
// ./Habit Rabbit/App/Extensions/Locale.swift
import SwiftUI

extension Locale {
    
    static var preferred: Locale {
        if let preferredIdentifier = Locale.preferredLanguages.first {
            return Locale(identifier: preferredIdentifier)
        } else {
            return Locale.current
        }
    }
    
}
// ./Habit Rabbit/App/Extensions/Notifications.swift
import SwiftUI
import Combine

extension View {
    
    func onCalendarDayChanged(action: @escaping () -> Void) -> some View {
        self.task {
            for await _ in NotificationCenter.default.notifications(named: .NSCalendarDayChanged) {
                action()
            }
        }
    }
    
}
// ./Habit Rabbit/App/Extensions/String.swift
import SwiftUI

extension String {
    
    func pluralized(count: Int) -> String {
        Self.pluralize(string: self, count: count)
    }
    
    static func pluralize(string: String, count: Int) -> String {
        let query = LocalizedStringResource("^[\(count) \(string)](inflect: true)")
        let attributed = AttributedString(localized: query)
        let localized = String(attributed.characters)
        let prefix = String(localized: "\(count) ")
        guard localized.hasPrefix(prefix) else { return localized }
        return String(localized.dropFirst(prefix.count))
    }
    
}
// ./Habit Rabbit/App/Extensions/View.swift
import SwiftUI

extension View {

    func debug(_ color: Color? = nil, _ width: CGFloat? = nil) -> some View {
        self.border(color ?? .orange, width: width ?? 2)
    }
    
    @ViewBuilder
    func `if`<TrueContent: View, FalseContent: View>(
        _ condition: Bool,
        @ViewBuilder then: (Self) -> TrueContent,
        @ViewBuilder `else`: (Self) -> FalseContent
    ) -> some View {
        if condition {
            then(self)
        } else {
            `else`(self)
        }
    }
    
    @ViewBuilder
    func `if`<TrueContent: View>(
        _ condition: Bool,
        @ViewBuilder then: (Self) -> TrueContent
    ) -> some View {
        if condition {
            then(self)
        } else {
            self
        }
    }
    
}
// ./Habit Rabbit/App/Models/Habit.swift
import SwiftUI
import SwiftData

@Model
class Habit {

    var name: String
    var unit: String
    var icon: String
    var target: Int
    var date: Date
    var kind: Habit.Kind
    var colorData: Data

    @Relationship(deleteRule: .cascade, inverse: \Habit.Value.habit)
    var values: [Habit.Value]?
    
    init(
        name: String,
        unit: String,
        icon: String,
        color: Color,
        target: Int,
        kind: Habit.Kind
    ) {
        self.name = name
        self.unit = unit
        self.icon = icon
        self.target = target
        self.date = .now
        self.kind = kind
        self.colorData = (try? NSKeyedArchiver.archivedData(
            withRootObject: UIColor(color),
            requiringSecureCoding: false)
        ) ?? Data()
    }
    
    enum Kind: String, Codable {
        case good
        case bad
    }
    
}

extension Habit {

    private static var colorCache: [Data: Color] = [:]
    
    var color: Color {
        if let cached = Habit.colorCache[colorData] {
            return cached
        }
        
        if let uiColor = try? NSKeyedUnarchiver.unarchivedObject(ofClass: UIColor.self, from: colorData) {
            let color = Color(uiColor)
            Self.colorCache[colorData] = color
            return color
        }
        
        Habit.colorCache[colorData] = .black
        return .black
    }
    
}

extension ModelContext {
    
    func insert(habit: Habit) {
        insert(habit)
        let value = Habit.Value(habit: habit, date: habit.date)
        insert(value)
    }
    
}

extension Habit {
    
    static var examples: [Habit] {[
        Habit(name: "Hydration",
              unit: "bottle",
              icon: "drop.fill",
              color: .blue,
              target: 3,
              kind: .good,
        ),
        Habit(name: "Smoking",
              unit: "cigarette",
              icon: "figure.strengthtraining.functional",
              color: .orange,
              target: 3,
              kind: .bad,
        ),
        Habit(name: "Meditation",
              unit: "session",
              icon: "figure.mind.and.body",
              color: .green,
              target: 3,
              kind: .good,
        ),
        Habit(name: "Reading",
              unit: "page",
              icon: "books.vertical.fill",
              color: .pink,
              target: 4,
              kind: .good,
        ),
        Habit(name: "Stretching",
              unit: "session",
              icon: "figure.strengthtraining.functional",
              color: .teal,
              target: 10,
              kind: .good,
        ),
        Habit(name: "Chores",
              unit: "task",
              icon: "house.fill",
              color: .red,
              target: 6,
              kind: .good,
        ),
        Habit(name: "Vocabulary",
              unit: "word",
              icon: "book.fill",
              color: .indigo,
              target: 5,
              kind: .good,
        ),
        Habit(name: "Stretching",
              unit: "minute",
              icon: "figure.cooldown",
              color: .brown,
              target: 10,
              kind: .good,
        ),
        Habit(name: "Journaling",
              unit: "entry",
              icon: "pencil.and.ellipsis.rectangle",
              color: .cyan,
              target: 1,
              kind: .good,
        ),
    ]}
    
}
// ./Habit Rabbit/App/Models/Value.swift
import SwiftUI
import SwiftData

extension Habit {

    @Model
    class Value {
        
        @Relationship
        var habit: Habit?
        
        var date: Date
        var currentValue: Int
        
        init(habit: Habit, date: Date, currentValue: Int = 0) {
            self.habit = habit
            self.date = date.startOfDay
            self.currentValue = currentValue
        }
        
    }
    
}

extension Habit.Value {

    static func filterBy(day date: Date, for habit: Habit) -> FetchDescriptor<Habit.Value> {
        filterBy(days: 1, endingOn: date, for: habit)
    }
    
    static func filterBy(days: Int, endingOn date: Date, for habit: Habit) -> FetchDescriptor<Habit.Value> {
        let habitID = habit.id
        
        let today = Calendar.current.startOfDay(for: date)
        let rangeStart = Calendar.current.date(byAdding: .day, value: -(days-1), to: today)!
        let rangeEnd = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        
        let predicate = #Predicate<Habit.Value> { value in
//            value.habit?.id == habitID
            value.habit?.persistentModelID == habitID
            && value.date >= rangeStart && value.date < rangeEnd
        }
        
        let sortByDate = SortDescriptor(\Habit.Value.date)
        var descriptor = FetchDescriptor(predicate: predicate, sortBy: [sortByDate])
        descriptor.fetchLimit = days
        descriptor.relationshipKeyPathsForPrefetching = [\Habit.Value.habit]
        
        return descriptor
    }
    
}
// ./Habit Rabbit/Views/Card/Card.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Card {
    
    @Observable
    class Manager {
        
        let habit: Habit
        let modelContext: ModelContext
        
        var lastDay: Date
        var mode: Habit.Card.Mode
        
        @ObservationIgnored
        var valueCache: [Date: Habit.Value] = [:]
        var values: [Habit.Value] = []

        init(
            for habit: Habit,
            until lastDay: Date,
            mode: Habit.Card.Mode,
            using modelContext: ModelContext,
        ) {
            self.habit = habit
            self.mode = mode
            self.lastDay = lastDay
            self.modelContext = modelContext
            
            fetchValues()
        }
        
        var name: String { habit.name }
        var unit: String { habit.unit }
        var icon: String { habit.icon }
        var color: Color { habit.color }
        var target: Int { habit.target }
        var kind: Habit.Kind { habit.kind }
        
    }
    
}
// ./Habit Rabbit/Views/Card/Card.swift
import SwiftUI
import SwiftData

extension Habit {

    struct Card: View {
        
        @Binding var editingHabit: Habit?

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.cardMode) var cardMode
        @Environment(\.cardOffset) var cardOffset
        @Environment(Card.Manager.self) var cardManager
        @Environment(Dashboard.Manager.self) var dashboardManager
        
        @Namespace var modeTransition

        var mode: Habit.Card.Mode { cardMode ?? cardManager.mode }
        
        @State var isDeleting = false
        
        var body: some View {
            VStack(spacing: 0) {
                Group {
                    switch mode {
                        case .daily: dailyView
                        case .weekly: weeklyView
                        case .monthly: monthlyView
                    }
                }
                .transition(.blurReplace)
                
                habitLabel
            }
            .animation(.spring(duration: 0.62), value: mode)
            .animation(.spring(duration: 0.62), value: cardManager.lastDay)
            .frame(maxWidth: .infinity)
            .frame(height: Card.Manager.cardHeight)
            .clipShape(.rect(cornerRadius: Card.Manager.cornerRadius))
            .background { Habit.Card.Background { colorEffect }.showShadows(false) }
            .geometryGroup()
            .scaleEffect(isDeleting ? 0 : 1)
            .contentShape(.contextMenuPreview, .rect(cornerRadius: Manager.cornerRadius))
            .contextMenu { contextMenuButtons }
            .offset(isDeleting ? deleteOffset : .zero)
            .compositingGroup()
        }
        
    }
    
}

extension Habit.Card {
    
    @ViewBuilder
    static func shadowEffect(_ colorScheme: ColorScheme) -> some View {
        if colorScheme == .light {
            RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius)
                .fill(.black.opacity(0.08))
                .blur(radius: 10)
                .offset(x: 0, y: 4)
            
            RoundedRectangle(cornerRadius: Habit.Card.Manager.cornerRadius)
                .fill(.black.opacity(0.04))
                .blur(radius: 4)
                .offset(x: 0, y: 2)
        }
    }
    
}

extension Habit.Card {
    
    var habitLabel: some View {
        VStack(spacing: mode == .monthly ? 4 : 2) {
            Label(String("\(cardManager.name)"), systemImage: cardManager.icon)
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.primary)
                .lineLimit(1)
            
            if mode != .daily {
                (
                    Text(verbatim: "\(cardManager.currentValue(for: mode))")
                        .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                    +
                    Text(verbatim: " / ")
                        .foregroundStyle(.primary.opacity(0.6))
                    +
                    Text(verbatim: "\(cardManager.currentTarget(for: mode))")
                        .foregroundStyle(.primary.opacity(0.6))
                )
                .font(.subheadline)
                .fontWeight(.semibold)
                .monospacedDigit()
                .contentTransition(.numericText())
            }
        }
        .frame(maxHeight: .infinity, alignment: .bottom)
        .padding(.bottom, cardManager.labelBottomPadding)
    }
    
    var colorEffect: some View {
        Rectangle()
            .fill(cardManager.color.gradient)
            .opacity(cardManager.isCompleted(for: mode) ? (colorScheme == .dark ? 0.5 : 0.7) : 0)
            .offset(x: 0, y: 180)
            .clipShape(.rect(cornerRadius: Manager.cornerRadius))
            .animation(.bouncy, value: cardManager.isCompleted(for: mode))
    }
    
}

extension EnvironmentValues {
    
    @Entry var cardOffset: Int = 0
    
}

extension Habit.Card {
    
    func deleteWithAnimation() {
        Task {
            try? await Task.sleep(nanoseconds: 10_000_000)
            withAnimation(.spring(duration: 0.8)) {
                isDeleting = true
            }
            
            try? await Task.sleep(nanoseconds: 10_000_000)
            cardManager.modelContext.delete(cardManager.habit)
            
            dashboardManager.refreshCardManagers()
        }
    }
    
    var deleteOffset: CGSize {
        let offset = (cardOffset % 2 == 0) ? -250 : 250
        return CGSize(width: CGFloat(offset), height: 100)
    }
    
}
// ./Habit Rabbit/Views/Card/Manager/Card.Manager.constants.swift
import SwiftUI

extension Habit.Card.Manager {
    
    static let cardHeight: CGFloat = 232
    static let cornerRadius: CGFloat = 24
    static let contentHeight: CGFloat = 155
    static let cubesGridHeight: CGFloat = 126 // 6 rows: 6 * 16 (cube) + 5 * 6 (spacing) = 126
    
    var labelBottomPadding: CGFloat {
        switch mode {
            case .daily: 20
            case .weekly: 10
            case .monthly: 14
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Manager/Card.Manager.lastDayOperations.swift
import SwiftUI

extension Habit.Card.Manager {
    
    enum DayShiftDirection {
        case yesterday
        case tomorrow
    }
    
    func shiftLastDay(to direction: DayShiftDirection) {
        switch direction {
            case .yesterday: shiftToYesterday()
            case .tomorrow: shiftToTomorrow()
        }
    }
    
}

extension Habit.Card.Manager {
    
    func shiftToYesterday() {
        // 1. Get the value for the new lastDay (yesterday)
        let newLastDay = lastDay.yesterday
        let newLastDayValue = fetchOrCreateValue(for: newLastDay)
        
        // 2. Create lookup dictionary for efficient operations
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        // 3. Cache values that are being removed from active window but keep them in cache
        let oldLastDay = self.lastDay
        if let removedValue = existingValues[oldLastDay] {
            valueCache[oldLastDay] = removedValue
        }
        
        // 4. Remove the OLD lastDay's value and build new values array
        var newValues = values.filter { !$0.date.isSameDay(as: oldLastDay) && !$0.date.isSameDay(as: newLastDay) }
        
        // 5. Insert the new oldest day's value (only if not already present)
        let newOldestDay = newLastDay.shift(days: -29)
        if existingValues[newOldestDay] == nil {
            let newOldestValue = fetchOrCreateValue(for: newOldestDay)
            newValues.insert(newOldestValue, at: 0)
        }
        
        // 6. Update lastDay and ensure its value is at the end
        lastDay = newLastDay
        newValues.append(newLastDayValue)
        values = newValues
        
        // 7. Cleanup cache periodically
        cleanupCache()
    }
    
    func shiftToTomorrow() {
        // 1. Get the value for the new lastDay (tomorrow)
        let newLastDay = lastDay.tomorrow
        let newLastDayValue = fetchOrCreateValue(for: newLastDay)
        
        // 2. Calculate which day is no longer in the 30-day window
        let oldestDayToRemove = newLastDay.shift(days: -30)
        
        // 3. Cache values that are being removed from active window
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        if let removedValue = existingValues[oldestDayToRemove] {
            valueCache[oldestDayToRemove] = removedValue
        }
        
        // 4. Filter out the oldest day and any existing entry for newLastDay
        values = values.filter { !$0.date.isSameDay(as: oldestDayToRemove) && !$0.date.isSameDay(as: newLastDay) }
        
        // 5. Update lastDay and append new value
        lastDay = newLastDay
        values.append(newLastDayValue)
        
        // 6. Cleanup cache periodically
        cleanupCache()
    }
    
}

extension Habit.Card.Manager {
    
    private func cleanupCache() {
        // Keep cache size reasonable by maintaining a window around lastDay (30 days in each direction)
        let pastCutoff = lastDay.shift(days: -30)
        let futureCutoff = lastDay.shift(days: 30)
        
        valueCache = valueCache.filter { date, _ in
            (pastCutoff...futureCutoff).contains(date)
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Manager/Card.Manager.valueOperations.swift
import SwiftUI

extension Habit.Card.Manager {
    
    func fetchOrCreateValue(for date: Date) -> Habit.Value {
        if let cachedValue = valueCache[date] {
            return cachedValue
        }
        
        let descriptor = Habit.Value.filterBy(day: date, for: habit)
        let fetchedValue = (try? modelContext.fetch(descriptor))?.first
        ?? {
            let newValue = Habit.Value(habit: habit, date: date)
            modelContext.insert(newValue)
            return newValue
        }()
        
        valueCache[date] = fetchedValue
        return fetchedValue
    }
    
    func fetchValues() {
        // fetch core 30 day window for active values
        let coreDescription = Habit.Value.filterBy(days: 30, endingOn: lastDay, for: habit)
        guard let coreValues = try? modelContext.fetch(coreDescription) else { return }
        values = coreValues
        
        // fetch extended window: additional 14 days in past and future for cache pre-loading
        let pastEnd = lastDay.shift(days: -30) // day before the 30-day window starts
        let pastDescription = Habit.Value.filterBy(days: 14, endingOn: pastEnd, for: habit)
        let pastValues = (try? modelContext.fetch(pastDescription)) ?? []
        
        let futureStart = lastDay.tomorrow
        let futureEnd = futureStart.shift(days: 14)
        let futureDescription = Habit.Value.filterBy(days: 14, endingOn: futureEnd, for: habit)
        let futureValues = (try? modelContext.fetch(futureDescription)) ?? []
        
        // populate cache with all fetched values (core + extended)
        for value in coreValues + pastValues + futureValues {
            valueCache[value.date] = value
        }
        
        // create lookup dictionary for efficient date checking
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        // abort if lastDay already exists
        guard existingValues[lastDay] == nil else { return }
        
        // create and save lastDay value
        let lastDayValue = Habit.Value(habit: self.habit, date: lastDay)
        modelContext.insert(lastDayValue)
        values.append(lastDayValue)
        valueCache[lastDay] = lastDayValue
    }
    
}

extension Habit.Card.Manager {
    
    private func cleanupCache() {
        // Keep cache size reasonable by maintaining a window around lastDay (30 days in each direction)
        let pastCutoff = lastDay.shift(days: -30)
        let futureCutoff = lastDay.shift(days: 30)
        
        valueCache = valueCache.filter { date, _ in
            (pastCutoff...futureCutoff).contains(date)
        }
    }
    
}

extension Habit.Card.Manager {
    
    func resetDailyValue() {
        dailyValue?.currentValue = 0
    }
    
    func randomizeDailyValue() {
        dailyValue?.currentValue = Int.random(in: 0...habit.target * 2)
    }
    
    func randomizeName() {
        habit.name = "Test \(Int.random(in: 1...1000))"
    }
    
    func randomizeMonthlyValues() {
        // create new values array
        var newValues: [Habit.Value] = []
        // create lookup of existing values
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { first, _ in first })
        
        // randomize values for the last 30 days
        for dayOffset in (0..<30).reversed() {
            let day = lastDay.shift(days: -dayOffset)
            let randomValue = Int.random(in: Int(Double(habit.target) * 0.8)...habit.target * 2)
            
            if let existingValue = existingValues[day] {
                // update existing value
                existingValue.currentValue = randomValue
                newValues.append(existingValue)
            } else {
                // create missing value
                let value = Habit.Value(habit: habit, date: day, currentValue: randomValue)
                modelContext.insert(value)
                newValues.append(value)
            }
        }
        
        // update with randomized values
        values = newValues
        
        // update cache with all randomized values
        for value in newValues {
            valueCache[value.date] = value
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Manager/Card.Manager.viewData.swift
import SwiftUI

extension Habit.Card.Manager {
    
    func currentValue(for mode: Habit.Card.Mode? = nil) -> Int {
        switch mode ?? self.mode {
            case .daily: dailyValue?.currentValue ?? 0
            case .weekly: weeklyValues.reduce(0) { $0 + $1.currentValue }
            case .monthly: values.reduce(0) { $0 + $1.currentValue }
        }
    }
    
    func currentTarget(for mode: Habit.Card.Mode? = nil) -> Int {
        switch mode ?? self.mode {
            case .daily: habit.target
            case .weekly: habit.target * 7
            case .monthly: habit.target * 30
        }
    }
    
    func isCompleted(for mode: Habit.Card.Mode? = nil) -> Bool {
        switch kind {
            case .good: currentValue(for: mode) >= currentTarget(for: mode)
            case .bad: currentValue(for: mode) < currentTarget(for: mode)
        }
    }
    
}

extension Habit.Card.Manager {
    
    var dailyValue: Habit.Value? { values.last }
    
    var weeklyValues: [Habit.Value] {
        let firstDay = lastDay.shift(days: -6)
        let allDays = (0..<7).map {
            firstDay.shift(days: $0)
        }
        
        let lookup = Dictionary(values.suffix(7).map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        return allDays.map { day in
            lookup[day] ?? Habit.Value(habit: habit, date: day, currentValue: 0)
        }
    }
    
    struct DayCell {
        let date: Date
        let value: Habit.Value?
    }
    
    var monthlyValues: [[DayCell]] {
        let firstDay = lastDay.shift(days: -29)
        let existingValues = Dictionary(values.map { ($0.date, $0) }, uniquingKeysWith: { _, latest in latest })
        
        let gridLastWeekFirstDay = Calendar.current.dateInterval(of: .weekOfYear, for: lastDay)!.start
        let gridLastDay = gridLastWeekFirstDay.shift(days: 6)
        let gridFirstDay = gridLastDay.shift(days: -41)

        let cells = (0..<42).map { offset in
            let day = gridFirstDay.shift(days: offset)

            let value = (firstDay...lastDay).contains(day)
                ? existingValues[day] ?? Habit.Value(habit: habit, date: day, currentValue: 0)
                : nil

            return DayCell(date: day, value: value)
        }
    
        let allRows = stride(from: 0, to: cells.count, by: 7).map { startIndex in
            Array(cells[startIndex..<min(startIndex + 7, cells.count)])
        }
        
        // Only show first row when lastDay is at the start of the week (Monday)
        let lastDayWeekdayIndex = Calendar.current.weekdayIndex(for: lastDay)
        let shouldShowFirstRow = lastDayWeekdayIndex == 0
        
        return shouldShowFirstRow ? allRows : Array(allRows.dropFirst())
    }
    
}
// ./Habit Rabbit/Views/Card/Manager/Card.Mode.swift
import SwiftUI

extension Habit.Card {
    
    enum Mode: String, CaseIterable, RawRepresentable, Identifiable {
        case daily = "daily"
        case weekly = "weekly"
        case monthly = "monthly"
        
        var id: Self { self }
        
        var localizedTitle: LocalizedStringKey {
            switch self {
                case .daily: "Daily"
                case .weekly: "Weekly"
                case .monthly: "Monthly"
            }
        }
    }
    
    func cardMode(_ mode: Habit.Card.Mode) -> some View {
        self.environment(\.cardMode, mode)
    }
    
}

extension Habit.Card.Manager {
    
    func updateMode(to newMode: Habit.Card.Mode) {
        if mode != newMode { mode = newMode }
    }
    
}

extension EnvironmentValues {
    
    @Entry var cardMode: Habit.Card.Mode? = nil
    
}
// ./Habit Rabbit/Views/Card/Views/Card.Background.swift
import SwiftUI

extension EnvironmentValues {
    
    @Entry var showShadows: Bool? = nil
    
}

extension Habit.Card.Background {
    
    func showShadows(_ show: Bool) -> some View {
        self.environment(\.showShadows, show)
    }
    
}

extension Habit.Card {
    
    struct Background<B: View, S: InsettableShape>: View {
        
        @Environment(\.colorScheme) var colorScheme
        @Environment(\.showShadows) var showShadows
        
        private let extraBackground: B
        private let shape: S
        private let material: Material
        
        init(
            shape: S,
            material: Material = .regularMaterial,
            @ViewBuilder background: () -> B
        ) {
            self.shape = shape
            self.material = material
            self.extraBackground = background()
        }
        
        var body: some View {
            shape
                .fill(material)
                .strokeBorder(.quaternary, lineWidth: colorScheme == .dark ? 1 : 0.6)
                .background {
                    if showShadows ?? true {
                        shadowView
                    }
                    extraBackground
                }
        }
        
        private var shadowView: some View {
            ZStack {
                if colorScheme == .light {
                    shape
                        .fill(.black.opacity(0.08))
                        .blur(radius: 10)
                        .offset(x: 0, y: 4)
                    
                    shape
                        .fill(.black.opacity(0.04))
                        .blur(radius: 4)
                        .offset(x: 0, y: 2)
                }
            }
        }
        
    }
    
}

extension Habit.Card.Background where S == RoundedRectangle {
    
    init(@ViewBuilder background: () -> B) {
        self.init(
            shape: .rect(cornerRadius: Habit.Card.Manager.cornerRadius),
            background: background
        )
    }
    
}

extension Habit.Card.Background where B == EmptyView, S == RoundedRectangle {
    
    init(shadow: Bool = true) {
        self.init(shape: .rect(cornerRadius: Habit.Card.Manager.cornerRadius)) {
            EmptyView()
        }
    }
    
}

extension Habit.Card.Background where B == EmptyView {
    
    init(in shape: S, material: Material = .regularMaterial) {
        self.init(shape: shape, material: material) { EmptyView() }
    }
    
}
// ./Habit Rabbit/Views/Card/Views/Card.contentMenuButtons.swift
import SwiftUI

extension Habit.Card {
    
    @ViewBuilder
    var contextMenuButtons: some View {
        Button("Edit", systemImage: "pencil") {
            //onEdit(cardManager.habit)
            editingHabit = cardManager.habit
        }
        
        #if DEBUG
        Button("Randomize", systemImage: "sparkles") {
            cardManager.randomizeDailyValue()
        }
        
        Button("Randomize Name", systemImage: "characters.uppercase") {
            cardManager.randomizeName()
        }
        
        Button("Reset", systemImage: "arrow.counterclockwise") {
            cardManager.dailyValue?.currentValue = 0
        }
        #endif
        
        Button("Delete", systemImage: "trash", role: .destructive) {
            deleteWithAnimation()
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Views/Card.Cube.swift
import SwiftUI

extension Habit.Card {

    struct Cube: View {

        @Environment(\.colorScheme) var colorScheme

        let value: Habit.Value?
        let habit: Habit

        var body: some View {
            RoundedRectangle(cornerRadius: 4)
                .fill(cubeStyle)
                .strokeBorder(.tertiary, lineWidth: cubeBorderWidth)
                .brightness(cubeBrightness)
                .frame(width: 16, height: 16)
        }

    }
    
}

extension Habit.Card.Cube {
    
    var cubeStyle: AnyShapeStyle {
        guard let value else {
            return switch habit.kind {
                case .good: AnyShapeStyle(.quaternary)
                case .bad: AnyShapeStyle(habit.color)
            }
        }
        
        let meetsTarget = switch habit.kind {
            case .good: value.currentValue >= habit.target
            case .bad: value.currentValue < habit.target
        }
        
        return switch meetsTarget {
            case true: AnyShapeStyle(habit.color)
            case false: AnyShapeStyle(.quaternary)
        }
    }
    
    var cubeBrightness: Double {
        guard let value else { return 0 }
        let isDark = colorScheme == .dark
        let exceedsTarget = value.currentValue > habit.target
        let meetsTarget = value.currentValue == habit.target
        
        return switch (habit.kind, isDark, exceedsTarget, meetsTarget) {
            case (.good, true, true, _)   :  0.1   // exceeding good habit in dark mode: brighter
            case (.good, true, false, _)  : -0.1   // not exceeding good habit in dark mode: darker
            case (.good, false, true, _)  : -0.1   // exceeding good habit in light mode: darker
            case (.good, false, false, _) :  0.1   // not exceeding good habit target in light mode: brighter
            case (.bad, _, false, false)  :  0     // below bad habit: no adjustment
            case (.bad, _, false, true)   :  0.2   // meeting bad habit: brighter
            case (.bad, true, true, _)    : -0.6   // exceeding bad habit in dark mode: much darker
            case (.bad, false, true, _)   : -0.8   // exceeding bad habit in light mode: darker
        }
    }
    
    var cubeBorderWidth: Double {
        guard let value else { return 0 }
        let isDark = colorScheme == .dark
        let exceedsTarget = value.currentValue > habit.target
        
        return switch (habit.kind, isDark, exceedsTarget) {
            case (.bad, true, true) : 0.75  // exceeding bad habit in dark mode: medium stroke
            default                 : 0     // no stroke
        }
    }
    
}
// ./Habit Rabbit/Views/Card/Views/Card.dailyView.swift
import SwiftUI

extension Habit.Card {
    
    var dailyView: some View {
        HStack(spacing: 0) {
            Habit.ProgressBar(
                value: cardManager.currentValue(for: mode),
                target: cardManager.target,
                color: cardManager.color,
                axis: .vertical,
                kind: cardManager.kind,
                mode: cardManager.mode,
                width: 50,
                height: Habit.Card.Manager.contentHeight
            )
            .matchedGeometryEffect(id: "progress\(cardManager.dailyValue?.date ?? cardManager.lastDay)", in: modeTransition, anchor: .topLeading)
            
            Spacer(minLength: 12)
            
            VStack(spacing: 0) {
                Habit.ProgressLabel(
                    value: cardManager.currentValue(for: mode),
                    target: cardManager.habit.target,
                    unit: cardManager.unit
                )
                .animation(.bouncy, value: cardManager.currentValue(for: mode))
                .frame(maxHeight: .infinity)
                
                Habit.ProgressButton()
                    .frame(width: 70, height: 70)
            }
        }
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.horizontal, 20)
        .padding(.top, 20)
    }
    
}


// ./Habit Rabbit/Views/Card/Views/Card.monthlyView.swift
import SwiftUI

extension Habit.Card {

    var monthlyView: some View {
        VStack(spacing: 6) {
            HStack(spacing: 6) {
                ForEach(dashboardManager.weekdaySymbols.enumerated, id: \.offset) { index, symbol in
                    Habit.WeekdaySymbol(
                        symbol: symbol,
                        color: weekdaySymbolStyle(for: index)
                    )
                    .frame(width: 16, height: 16)
                }
            }
            .padding(.top, 4)
            .padding(.bottom, 2)
            
            VStack(spacing: 6) {
                ForEach(cardManager.monthlyValues, id: \.first?.date) { weekValues in
                    HStack(spacing: 6) {
                        ForEach(weekValues, id: \.date) { cell in                        
                            Habit.Card.Cube(
                                value: cell.value,
                                habit: cardManager.habit
                            )
                            .opacity(cell.value == nil ? 0 : 1)
                            .matchedGeometryEffect(id: "progress\(cell.date)", in: modeTransition)
                            .animation(.bouncy, value: cell.value?.currentValue)
                        }
                    }
                }
            }
            .compositingGroup()
            .geometryGroup()
            .frame(height: Habit.Card.Manager.cubesGridHeight)
            .frame(maxWidth: .infinity)
            .clipped()
        }
        .geometryGroup()
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.top, 10)
    }
    
}

extension Habit.Card {
    
    private func weekdaySymbolStyle(for index: Int) -> Color {
        .primary.opacity(index == dashboardManager.lastDayIndex ? 0.8 : 0.4)
    }

}

// ./Habit Rabbit/Views/Card/Views/Card.NavigationButton.swift
import SwiftUI

extension Habit.Card {
    
    struct NavigationButton: View {
        
        @Binding var editingHabit: Habit?

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.cardOffset) var cardIndex
        @Environment(Habit.Card.Manager.self) var cardManager
        @Environment(Habit.Dashboard.Manager.self) var dashboardManager
        
        @Namespace var habitTransition
        
        var body: some View {
            NavigationLink {
                Habit.Card.DetailView()
                    .environment(cardManager)
                    .environment(dashboardManager)
                    .navigationTransition(.zoom(sourceID: cardManager.habit.id, in: habitTransition))
            } label: {
                Habit.Card(editingHabit: $editingHabit)
                    .environment(cardManager)
                    .environment(\.cardOffset, cardIndex)
                    .matchedTransitionSource(id: cardManager.habit.id, in: habitTransition)
            }
            .fontDesign(.rounded)
            .buttonStyle(.plain)
            .background { Habit.Card.shadowEffect(colorScheme) }
        }
        
    }
    
}
// ./Habit Rabbit/Views/Card/Views/Card.weeklyView.swift
import SwiftUI

extension Habit.Card {
    
    var weeklyView: some View {
        VStack(alignment: .leading, spacing: 9) {
            ForEach(cardManager.weeklyValues.enumerated, id: \.element.id) { index, value in
                HStack(spacing: 12) {
                    Habit.WeekdaySymbol(
                        symbol: dashboardManager.weekdaySymbol(for: value.date),
                        color: .primary.opacity(index == 6 ? 0.8 : 0.4)
                    )
                    .frame(width: 10, height: 13)
                    
                    Habit.ProgressBar(
                        value: value.currentValue,
                        target: cardManager.habit.target,
                        color: cardManager.color,
                        axis: .horizontal,
                        kind: cardManager.habit.kind,
                        mode: cardManager.mode,
                        width: 118,
                        height: 13,
                    )
                    .matchedGeometryEffect(id: "progress\(value.date)", in: modeTransition, anchor: .leading)
                }
                .compositingGroup()
                .geometryGroup()
                .frame(maxWidth: .infinity)
            }
        }
        .geometryGroup()
        .frame(height: Habit.Card.Manager.contentHeight)
        .padding(.top, 18)
        .padding(.trailing, 4)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Dashboard.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Dashboard {
    
    @Observable
    class Manager {

        var lastDay: Date
        var modelContext: ModelContext
        
        var lastDayIndex: Int
        let weekdaySymbols: [String]
                
        var modeCache: Habit.Card.Mode?
        var mode: Habit.Card.Mode {
            get { loadMode() }
            set { saveMode(newValue) }
        }
        
        @ObservationIgnored
        var cardManagerCache: [PersistentIdentifier: Habit.Card.Manager] = [:]
        var cardManagers: [Habit.Card.Manager] = []
                
        init(
            mode: Habit.Card.Mode? = nil,
            lastDay: Date = .now.startOfDay,
            using modelContext: ModelContext
        ) {
            self.lastDay = lastDay
            self.weekdaySymbols = Calendar.current.weekdaySymbols
            self.lastDayIndex = Calendar.current.weekdayIndex(for: lastDay)
            self.modelContext = modelContext
            
            if let mode {
                self.modeCache = mode
                UserDefaults.standard.set(mode.rawValue, forKey: "dashboardMode")
            }
                                        
            refreshCardManagers()
        }
        
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Dashboard.swift
import SwiftUI

extension Habit {
    
    struct Dashboard: View {
        
        @Environment(\.colorScheme) var colorScheme
        @Environment(Habit.Dashboard.Manager.self) var dashboardManager

        @State var showAddSheet = false
        @State var editingHabit: Habit?
        
        @Namespace var unionNamespace
        
        var cardManagers: [Habit.Card.Manager] { dashboardManager.cardManagers }

        var body: some View {
            NavigationStack {
                ScrollView {
                    LazyVGrid(columns: columns, spacing: 16) {
                        ForEach(cardManagers.enumerated, id: \.element.habit.id) { index, cardManager in
                            Habit.Card.NavigationButton(editingHabit: $editingHabit)
                                .environment(cardManager)
                                .environment(dashboardManager)
                                .environment(\.cardOffset, index)
                        }
                    }
                    .safeAreaInset(edge: .top, spacing: 0) { emptyView }
                    .safeAreaPadding(.top, 10)
                    .padding(.horizontal, 16)
                    .padding(.bottom, 16)
                }
                .scrollEdgeEffectHidden(for: .bottom)
                .safeAreaPadding(.top, 6)
                .safeAreaBar(edge: .top) { controls }
                .safeAreaBar(edge: .bottom, alignment: .trailing) { addButton }
                .toolbar { title }
                .toolbarRole(.browser)
                .toolbarTitleDisplayMode(.inline)
                .animation(.default, value: cardManagers.count)
                .sheet(isPresented: $showAddSheet) { Sheet.Add() }
                .sheet(item: $editingHabit) { Sheet.Edit(habit: $0) }
            }
            .tint(colorScheme == .dark ? .white : .black)
            .sensoryFeedback(.selection, trigger: dashboardManager.mode)
            .sensoryFeedback(.selection, trigger: dashboardManager.lastDay)
            .onCalendarDayChanged { dashboardManager.setLastDay(to: .now) }
        }
        
        private let columns = [
            GridItem(.flexible(), spacing: 16),
            GridItem(.flexible(), spacing: 16),
        ]
        
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Manager/Dashboard.Manager.cardManagers.swift
import SwiftUI
import SwiftData

extension Habit.Dashboard.Manager {
    
    // clear all card managers from cache
    func deleteCardManagers() {
        cardManagerCache.removeAll()
    }
    
    // rebuild all card managers from scratch
    func refreshCardManagers() {
        var newCache: [PersistentIdentifier: Habit.Card.Manager] = [:]
        
        let query = FetchDescriptor<Habit>(sortBy: [SortDescriptor(\.date)])
        
        guard let habits = try? modelContext.fetch(query) else { return }
        
        for habit in habits {
            if let cachedManager = cardManagerCache[habit.id] {
                newCache[habit.id] = cachedManager
                continue
            }
            
            newCache[habit.id] = Habit.Card.Manager(
                for: habit,
                until: lastDay,
                mode: mode,
                using: modelContext
            )
        }
        
        self.cardManagerCache = newCache
        self.cardManagers = habits.compactMap { newCache[$0.id] }
    }
    
}

extension Habit.Dashboard.Manager {
    
    func updateMode(to newMode: Habit.Card.Mode) {
        if newMode == mode { return }
        mode = newMode
        synchronizeCardModes()
    }
    
    func synchronizeCardModes() {
        cardManagers.forEach { $0.updateMode(to: mode) }
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Manager/Dashboard.Manager.habitOperations.swift
import SwiftUI

extension Habit.Dashboard.Manager {
    
    func addHabit(_ habit: Habit) {
        addHabits([habit])
    }
    
    func addHabits(_ habits: [Habit]) {
        habits.forEach { modelContext.insert(habit: $0) }
        try? modelContext.save()
        refreshCardManagers()
    }
    
}

extension Habit.Dashboard.Manager {
    
    func updateHabit(
        _ habit: Habit,
        with newHabit: Habit
    ) {
        updateHabit(
            habit,
            name: newHabit.name,
            unit: newHabit.unit,
            icon: newHabit.icon,
            color: newHabit.color,
            target: newHabit.target,
            kind: newHabit.kind
        )
    }
    
    func updateHabit(
        _ habit: Habit,
        name: String,
        unit: String,
        icon: String,
        color: Color,
        target: Int,
        kind: Habit.Kind
    ) {
        habit.name = name
        habit.unit = unit
        habit.icon = icon
        habit.target = target
        habit.kind = kind
        habit.colorData = (try? NSKeyedArchiver.archivedData(
            withRootObject: UIColor(color),
            requiringSecureCoding: false)
        ) ?? Data()
        
        guard let _ = try? modelContext.save() else { return }
        refreshCardManagers()
    }
    
}

extension Habit.Dashboard.Manager {
    
    func addExampleHabits(count: Int) {
        let templates = Habit.examples
        guard !templates.isEmpty else { return }
        
        let habits = (0..<count).map { i in
            let template = templates[i % templates.count]
            return Habit(
                name: template.name,
                unit: template.unit,
                icon: template.icon,
                color: template.color,
                target: template.target,
                kind: template.kind
            )
        }
        
        addHabits(habits)
    }

    func randomizeAllHabits() {
        cardManagers.forEach { $0.randomizeMonthlyValues() }
    }
    
    func resetLatestHabits() {
        cardManagers.forEach { $0.resetDailyValue() }
    }
    
    func deleteAllHabits() throws {
        try modelContext.delete(model: Habit.self)
        try modelContext.save()
        refreshCardManagers()
    }
    
    func deleteAllData() {
        modelContext.container.deleteAllData()
        refreshCardManagers()
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Manager/Dashboard.Manager.lastDayOperations.swift
import SwiftUI

extension Habit.Dashboard.Manager {
    
    typealias Direction = Habit.Card.Manager.DayShiftDirection
    
    func shiftLastDay(to direction: Direction) {
        let offset = direction == .tomorrow ? 1 : -1
        lastDay = Calendar.current.date(byAdding: .day, value: offset, to: lastDay)!
        lastDayIndex = Calendar.current.weekdayIndex(for: lastDay)
        
        for cardManager in cardManagers {
            cardManager.shiftLastDay(to: direction)
        }
    }
    
    func setLastDay(to date: Date) {
        guard !date.isSameDay(as: lastDay) else { return }
        let date = date.startOfDay
        
        let dayDifference = Calendar.current.dateComponents([.day], from: lastDay, to: date).day!
        
        switch dayDifference {
            case  1: shiftLastDay(to: .tomorrow)
            case -1: shiftLastDay(to: .yesterday)
            default:
                lastDay = date
                lastDayIndex = Calendar.current.weekdayIndex(for: date)
                deleteCardManagers()
                refreshCardManagers()
        }
    }
    
}

extension Habit.Dashboard.Manager {
    
    func weekdaySymbol(for date: Date) -> String {
        let index = Calendar.current.weekdayIndex(for: date)
        guard weekdaySymbols.indices.contains(index) else { return "?" }
        return weekdaySymbols[index]
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Manager/Dashboard.Manager.modePersistance.swift
import SwiftUI

extension Habit.Dashboard.Manager {
    
    func loadMode() -> Habit.Card.Mode {
        if let modeCache { return modeCache }
        else if let rawValue = UserDefaults.standard.string(forKey: "dashboardMode"),
                let mode = Habit.Card.Mode(rawValue: rawValue) {
            modeCache = mode
            return mode
        } else {
            modeCache = .daily
            return .daily
        }
    }
    
    func saveMode(_ newMode: Habit.Card.Mode) {
        modeCache = newMode
        UserDefaults.standard.set(newMode.rawValue, forKey: "dashboardMode")
        synchronizeCardModes()
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.addButton.swift
import SwiftUI

extension Habit.Dashboard {
    
    var addButton: some View {
        Button {
            showAddSheet = true
        } label: {
            Image(systemName: "plus")
                .font(.title)
                .fontWeight(.medium)
                .padding()
        }
        .buttonStyle(.glass)
        .clipShape(.circle)
        .buttonBorderShape(.circle)
        .sensoryFeedback(.selection, trigger: showAddSheet)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.controls.swift
import SwiftUI

extension Habit.Dashboard {
    
    var controls: some View {
        HStack(spacing: 16) {
            GlassEffectContainer {
                HStack(spacing: -10) {
                    Button("Back", systemImage: "chevron.left") {
                        dashboardManager.shiftLastDay(to: .yesterday)
                    }
                    Button("Forward", systemImage: "chevron.right") {
                        dashboardManager.shiftLastDay(to: .tomorrow)
                    }
                }
                .fontWeight(.semibold)
                .labelStyle(.iconOnly)
                .controlSize(.large)
                .buttonStyle(.glass)
                .glassEffectUnion(id: "group", namespace: unionNamespace)
            }
            
            @Bindable var manager = dashboardManager
            Picker("View Mode", selection: $manager.mode) {
                ForEach(Habit.Card.Mode.allCases) { item in
                    Text(item.localizedTitle)
                }
            }
            .glassEffect()
            .pickerStyle(.segmented)
            .controlSize(.large)
        }
        .fontDesign(.rounded)
        .padding(.horizontal, 16)
        .padding(.leading, 6)
        .padding(.top, 24)
        .padding(.bottom, 4)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.debug.swift
import SwiftUI

extension Habit.Dashboard {
    
    var debugToolbarMenu: some ToolbarContent {
        ToolbarTitleMenu {
            addExampleButton
            randomizeButton
            resetLatestButton
            Divider()
            killDatabaseButton
            deleteHabitsButton
        }
    }
    
}

extension Habit.Dashboard {
    
    var addExampleButton: some View {
        Menu {
            ForEach([1, 2, 4, 8, 20, 50, 100], id: \.self) { count in
                Button(String("\(count)")) {
                    dashboardManager.addExampleHabits(count: count)
                }
            }
        } label: {
            Label("Add Examples", systemImage: "plus")
        }
    }
    
    var randomizeButton: some View {
        Button("Randomize All", systemImage: "sparkles") {
            dashboardManager.randomizeAllHabits()
        }
    }
    
    var resetLatestButton: some View {
        Button("Reset Latest", systemImage: "0.circle") {
            dashboardManager.resetLatestHabits()
        }
    }
    
}

extension Habit.Dashboard {
    
    var killDatabaseButton: some View {
        Button("Kill Database", systemImage: "xmark", role: .destructive) {
            dashboardManager.deleteAllData()
        }
    }
    
    var deleteHabitsButton: some View {
        Button("Delete All", systemImage: "trash", role: .destructive) {
            try? dashboardManager.deleteAllHabits()
        }
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.empty.swift
import SwiftUI

extension Habit.Dashboard {
    
    @ViewBuilder
    var emptyView: some View {
        if cardManagers.isEmpty {
            ContentUnavailableView(
                "No Habits",
                systemImage: "rectangle.portrait.slash.fill",
                description: Text("Create your first habit to get started!")
            )
        }
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.title.swift
import SwiftUI

extension Habit.Dashboard {
    
    var title: some ToolbarContent {
        ToolbarItem(placement: .principal) {
            VStack(alignment: .leading, spacing: 0) {
                Text(verbatim: "Habit Rabbit")
                    .font(.largeTitle)
                Text(verbatim: dashboardManager.lastDay.formatted(.weekdayDate))
                    .font(.callout)
                    .foregroundStyle(.secondary)
                    .fontDesign(.monospaced)
            }
            .fontWeight(.semibold)
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(.top, 12)
            .padding(.leading, 4)
        }
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Dashboard.Sheet.keyboard.swift
import SwiftUI

extension Habit.Dashboard.Sheet {
    
    enum FocusedField: CaseIterable {
        case habitName
        case habitUnit
        case target
        case icon
    }
    
    func advanceToNextField(from currentField: FocusedField? = nil) {
        let currentField = currentField ?? focusedField
        guard let currentField else { return }
        let nextField = currentField.next
        
        if nextField == .icon {
            focusedField = .icon
            showIconPicker = true
            focusedField = nil
        } else {
            focusedField = nextField
        }
    }
    
    func advanceToPreviousField() {
        guard let currentField = focusedField else { return }
        focusedField = currentField.previous
    }
    
    var keyboardButtons: some ToolbarContent {
        ToolbarItem(placement: .keyboard){
            HStack {
                Button("Previous") { advanceToPreviousField() }
                    .disabled(focusedField?.isFirst == true)
                    .fontWeight(.semibold)
                
                Button("Next") { advanceToNextField() }
                    .disabled(focusedField?.isLast == true)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button("Done") { focusedField = nil }
                    .fontWeight(.semibold)
            }
        }
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Dashboard.Sheet.swift
import SwiftUI
import SwiftData

extension Habit.Dashboard {
    
    struct Sheet: View {
        
        @Environment(\.colorScheme) var colorScheme
        
        let initial: InitialValues
        let submitLabel: String
        let submitIcon: String
        let onSubmit: (Habit) -> ()
        
        @FocusState var focusedField: FocusedField?
        
        @State var name: String
        @State var unit: String
        @State var icon: String
        @State var selectedColorIndex: Int
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var kind: Habit.Kind
        
        let horizontalPadding: CGFloat = 16
        
        struct InitialValues {
            
            var name: String
            var unit: String
            var icon: String
            var color: Color
            var target: Int?
            var kind: Habit.Kind
            
        }
        
        init(
            initial: InitialValues,
            submitLabel: String,
            submitIcon: String,
            onSubmit: @escaping (Habit) -> ()
        ) {
            self.initial = initial
            self.submitLabel = submitLabel
            self.submitIcon = submitIcon
            self.onSubmit = onSubmit
            self._name = State(initialValue: initial.name)
            self._unit = State(initialValue: initial.unit)
            self._icon = State(initialValue: initial.icon)
            let colorIndex = Edit.colorIndex(for: initial.color)
            self._selectedColorIndex = State(initialValue: colorIndex)
            self._targetValue = State(initialValue: initial.target)
            self._kind = State(initialValue: initial.kind)
        }
    }
}

extension Habit.Dashboard.Sheet {

    var body: some View {
        ScrollView {
            VStack(spacing: 14) {
                kindSection
                nameSection
                Divider()
                unitSection
                Divider()
                targetSection
                Divider()
                iconSection
                Divider()
                colorSection
            }
            .padding(horizontalPadding)
            .padding(.horizontal, horizontalPadding)
        }
        .scrollBounceBehavior(.basedOnSize)
        .overlay(alignment: .bottom) {
            Button(role: .none) {
                handleSubmit()
            } label: {
                Label(submitLabel, systemImage: submitIcon)
                    .fontWeight(.semibold)
            }
            .buttonStyle(.borderedProminent)
            .buttonBorderShape(.capsule)
            .tint(.blue)
            .disabled(!isFormValid)
            .padding(.vertical, 32)
        }
        .ignoresSafeArea(.keyboard)
        .toolbar { keyboardButtons }
        .sheet(isPresented: $showIconPicker) { iconPickerSheet }
    }

}


extension Habit.Dashboard.Sheet {

    private var isFormValid: Bool {
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return false }
        guard !unit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return false }
        guard let targetValue, targetValue > 0 else { return false }
        return true
    }
    
    private func handleSubmit() {
        guard isFormValid, let targetValue else { return }
        let habit = Habit(
            name: name.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: unit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: icon,
            color: Self.availableColors[selectedColorIndex],
            target: targetValue,
            kind: kind
        )
        onSubmit(habit)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.color.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var colorSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Color")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            colorPicker
        }
    }
    
    private var colorPicker: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                ForEach(Self.availableColors.enumerated, id: \.offset) { index, clr in
                    Button {
                        selectedColorIndex = index
                    } label: {
                        Circle()
                            .fill(clr.gradient)
                            .frame(width: 44, height: 44)
                            .overlay {
                                if selectedColorIndex == index {
                                    Circle()
                                        .strokeBorder(.primary, lineWidth: 3)
                                }
                            }
                    }
                    .buttonStyle(.plain)
                }
            }
        }
        .contentMargins(.horizontal, horizontalPadding * 2)
        .padding(.horizontal, -horizontalPadding * 2)
    }
    
    static let availableColors: [Color] = [
        .blue,
        .orange,
        .green,
        .pink,
        .mint,
        .purple,
        .yellow,
        .red,
        .teal,
        .indigo,
        .brown,
        .gray,
        .cyan,
    ]

}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.icon.swift
import SwiftUI

extension Habit.Dashboard.Sheet {
    
    var iconSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Icon")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            iconPickerButton
                .font(.title3)
                .fontWeight(.semibold)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
    private var iconPickerButton: some View {
        Button {
            showIconPicker = true
        } label: {
            HStack(alignment: .lastTextBaseline) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundStyle(colorScheme == .light ? .black : .white)
                    .padding(.leading, 1)
                
                Text("Change")
                    .font(.subheadline)
                    .fontWeight(.bold)
                    .foregroundStyle(.secondary)
            }
        }
        .buttonStyle(.plain)
    }
    
    var iconPickerSheet: some View {
        NavigationStack {
            ScrollView {
                LazyVGrid(columns: columns, spacing: 10) {
                    ForEach(Self.commonIcons, id: \.self) { icon in
                        Button {
                            Task {
                                self.icon = icon
                                try? await Task.sleep(for: .milliseconds(100))
                                showIconPicker = false
                                focusedField = nil
                            }
                        } label: {
                            Image(systemName: icon)
                                .font(.title3)
                                .frame(width: 44, height: 44)
                                .padding(4)
                                .background {
                                    switch self.icon == icon {
                                        case true:  Circle().fill(.blue)
                                        case false: Habit.Card.Background(in: .circle).showShadows(false)
                                    }
                                }
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.vertical, 32)
                .padding(.horizontal, 16)
            }
            .toolbar { closeButton }
        }
        .presentationDetents([.large])
        .presentationBackground {
            Rectangle()
                .fill(.thickMaterial)
                .padding(.bottom, -100)
        }
    }
    
    private var closeButton: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button(role: .cancel) {
                showIconPicker = false
                focusedField = nil
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .tint(.red)
        }
    }
    
    var columns: [GridItem] {
        Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)
    }
    
    static let commonIcons: [String] = [
        // communitction
        "microphone.fill",
        "message.fill",
        "quote.closing",
        "phone.fill",
        "video.fill",
        "envelope.front.fill",
        "envelope.fill",
        "waveform",
        "recordingtape",
        "shippingbox.fill",
        "clock.fill",
        "alarm.fill",
        "hourglass",
        
        
        // eat & drink
        "cup.and.saucer.fill",
        "mug.fill",
        "takeoutbag.and.cup.and.straw.fill",
        "wineglass.fill",
        "waterbottle.fill",
        "birthday.cake.fill",
        "carrot.fill",
        "fork.knife",
        "scalemass.fill",
        
        // personal
        "shower.fill",
        "bathtub.fill",
        "comb.fill",
        "sunglasses",
        
        "frying.pan.fill",
        "bed.double.fill",
        "washer.fill",
        "dryer.fill",
        "dishwasher.fill",
        "oven.fill",
        "stove.fill",
        "refrigerator.fill",
        "toilet.fill",
        "teddybear.fill",
        "gift.fill",
        
        
        // leasure
        "videoprojector.fill",
        "party.popper.fill",
        "balloon.2.fill",
        "laser.burst",
        "popcorn.fill",
        "stroller.fill",
        "movieclapper",
        "ticket.fill",
        "film.stack.fill",
        "gamecontroller.fill",
        "paintpalette.fill",
        
        // nature
        "tree.fill",
        "fossil.shell.fill",
        
        
        // games
        "puzzlepiece.extension.fill",
        "theatermasks.fill",
        "theatermask.and.paintbrush.fill",
        
        // weather
        "sun.max.fill",
        "sunrise.fill",
        "sunset.fill",
        "sun.horizon.fill",
        "sun.rain.fill",
        "moon.fill",
        "moon.stars.fill",
        "cloud",
        "smoke.fill",
        "cloud.rain.fill",
        "cloud.bolt.fill",
        "cloud.sun.fill",
        "wind",
        "snowflake",
        "tornado",
        "thermometer.high",
        "degreesign.fahrenheit",
        "degreesign.celsius",
        "rainbow",
        
        // maps
        "figure.walk",
        "figure.wave",
        "cart.fill",
        "basket.fill",
        "creditcard.fill",
        "wallet.bifold.fill",
        "wand.and.sparkles.inverse",
        
        "location.fill",
        "mappin",
        "map.fill",
        "car.fill",
        "bus.fill",
        "tram.fill",
        "bicycle",
        "fuelpump.fill",
        "licenseplate.fill",
        "point.bottomleft.forward.to.point.topright.scurvepath.fill",
        "binoculars.fill",
        "tent.fill",
        "signpost.right.fill",
        "fuelpump.fill",
        
        // office
        "door.left.hand.open",
        "door.left.hand.closed",
        "door.sliding.right.hand.open",
        "door.sliding.right.hand.closed",
        "door.garage.open",
        "door.garage.closed",
        "air.purifier.fill",
        "heater.vertical.fill",
        "spigot.fill",
        
        "pencil.and.scribble",
        "rectangle.and.pencil.and.ellipsis",
        "highlighter",
        "square.and.pencil",
        "eraser.fill",
        "paperplane.fill",
        "tray.full.fill",
        "tray.2.fill",
        "archivebox.fill",
        "externaldrive.fill",
        "document.fill",
        "document.on.document.fill",
        "list.bullet.clipboard.fill",
        "pencil.and.list.clipboard",
        "note.text",
        "calendar",
        "book.fill",
        "text.book.closed.fill",
        "magazine.fill",
        "newspaper.fill",
        "books.vertical.fill",
        "menucard.fill",
        "bookmark.fill",
        "paperclip",
        "link",
        "gauge.with.dots.needle.bottom.0percent",
        "dice.fill",
        "printer.fill",
        "scanner.fill",
        "headset",
        "radio.fill",
        "battery.100percent",
        "battery.100percent.bolt",
        
        // wear
        "graduationcap.fill",
        "backpack.fill",
        "bag.fill",
        "handbag.fill",
        "briefcase.fill",
        "suitcase.fill",
        "suitcase.cart.fill",
        "suitcase.rolling.fill",
        
        // tools
        "ruler.fill",
        "flashlight.on.fill",
        "camera.fill",
        "web.camera.fill",
        "gear",
        "scissors",
        "paintbrush.fill",
        "paintbrush.pointed.fill",
        "level.fill",
        "wrench.adjustable.fill",
        "hammer.fill",
        "screwdriver.fill",
        "eyedropper.halffull",
        "lightbulb.fill",
        "fan.fill",
        "poweroutlet.strip.fill",
        "powerplug.fill",
        "lock.fill",
        "lock.open.fill",
        "key.fill",
        "pin.fill",
        
        // sport
        "dumbbell.fill",
        "soccerball.inverse",
        "baseball.fill",
        "basketball.fill",
        "american.football.fill",
        "tennis.racket",
        "tennisball.fill",
        "volleyball.fill",
        "skateboard",
        "skis.fill",
        "snowboard.fill",
        "surfboard.fill",
        "rosette",
        "medal.fill",
        "medal.star.fill",
        "shield.fill",
        "trophy.fill",
        "sailboat.fill",
        "helmet.fill",
        "hat.cap.fill",
        "tshirt.fill",
        "jacket.fill",
        "coat.fill",
        "shoe.fill",
        "hat.widebrim.fill",
        "crown.fill",
        
        // music
        "pianokeys.inverse",
        "guitars.fill",
        
        // medical
        "inhaler.fill",
        "cross.case.fill",
        "syringe.fill",
        "pill.fill",
        "cross.vial.fill",
        
        // other
        "tag.fill",
        "lasso",
        "trash",
        "folder.fill",
        "megaphone.fill",
        "speaker.wave.2.fill",
        "bell.fill",
        "music.microphone",
        "magnifyingglass",
        "flag.fill",
        "flag.pattern.checkered",
        "flag.2.crossed.fill",
    ]
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.kind.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var kindSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Habit")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            SegmentedControl(
                selection: $kind,
                options: [
                    (value: Habit.Kind.good, icon: "hand.thumbsup.fill", text: String(localized: "Good"), color: .green),
                    (value: Habit.Kind.bad, icon: "hand.raised.fill", text: String(localized: "Bad"), color: .red)
                ]
            )
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.name.swift
import SwiftUI

extension Habit.Dashboard.Sheet {
    
    var nameSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Name")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField("Stretching", text: $name)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .focused($focusedField, equals: .habitName)
                .onSubmit {
                    Task {
                        try? await Task.sleep(for: .milliseconds(300))
                        advanceToNextField(from: .habitName)
                    }
                }
                .submitLabel(.next)
                .autocorrectionDisabled()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.target.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var targetSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Target")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField(String("6"), value: $targetValue, format: .number)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .keyboardType(.numberPad)
                .focused($focusedField, equals: .target)
                .onSubmit {
                    advanceToNextField()
                }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sections/Dashboard.Sheet.unit.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    var unitSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Unit")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundStyle(.secondary)
            
            TextField("Sessions", text: $unit)
                .textFieldStyle(.plain)
                .font(.title)
                .fontWeight(.semibold)
                .focused($focusedField, equals: .habitUnit)
                .onSubmit {
                    Task {
                        try? await Task.sleep(for: .milliseconds(300))
                        advanceToNextField(from: .habitUnit)
                    }
                }
                .submitLabel(.next)
                .autocorrectionDisabled()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sheets/Dashboard.Sheet.Add.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    struct Add: View {

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.dismiss) private var dismiss
        @Environment(Habit.Dashboard.Manager.self) private var dashboardManager
        
        @FocusState var focusedField: Habit.Dashboard.Sheet.FocusedField?

        @State var habitName = ""
        @State var habitUnit = ""
        @State var selectedIcon = "star.fill"
        @State var selectedColor: Color = .blue
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var habitKind: Habit.Kind = .good
        
        let horizontalPadding: CGFloat = 16
        let columns = Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)

        var body: some View {
            NavigationStack {
                Habit.Dashboard.Sheet(
                    initial: .init(
                        name: "",
                        unit: "",
                        icon: "star.fill",
                        color: .blue,
                        target: nil,
                        kind: .good
                    ),
                    submitLabel: String(localized: "Add Habit"),
                    submitIcon: "plus",
                    onSubmit: { newHabit in
                        dashboardManager.addHabit(newHabit)
                        dismiss()
                    }
                )
                .toolbar { closeButton }
                .presentationBackground {
                    Rectangle()
                        .fill(.thickMaterial)
                        .padding(.bottom, -100)
                }
                .presentationDetents([.large])
                .interactiveDismissDisabled()
                .navigationTitle("Add Habit")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
        
    }
    
}

extension Habit.Dashboard.Sheet.Add {
    
    private var closeButton: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button(role: .cancel) {
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .tint(.red)
        }
    }
    
}

extension Habit.Dashboard.Sheet.Add {
    
    private var isFormValid: Bool {
        !habitName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !habitUnit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        targetValue != nil && targetValue! > 0
    }
    
    private func addHabit() {
        guard isFormValid else { return }
        guard let targetValue else { return }
        
        let habit = Habit(
            name: habitName.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: habitUnit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: selectedIcon,
            color: selectedColor,
            target: targetValue,
            kind: habitKind
        )
        
        dashboardManager.addHabit(habit)
        dismiss()
    }

}
// ./Habit Rabbit/Views/Dashboard/Views/Dashboard.Sheet/Sheets/Dashboard.Sheet.Edit.swift
import SwiftUI

extension Habit.Dashboard.Sheet {

    struct Edit: View {

        @Environment(\.colorScheme) var colorScheme
        @Environment(\.dismiss) private var dismiss
        @Environment(Habit.Dashboard.Manager.self) private var dashboardManager
        
        let habit: Habit
        
        @FocusState var focusedField: Habit.Dashboard.Sheet.FocusedField?

        @State var habitName: String
        @State var habitUnit: String
        @State var selectedIcon: String
        @State var selectedColorIndex: Int
        @State var showIconPicker = false
        @State var targetValue: Int?
        @State var habitKind: Habit.Kind
        
        let horizontalPadding: CGFloat = 16
        let columns = Array(repeating: GridItem(.flexible(), spacing: 16), count: 6)

        init(habit: Habit) {
            self.habit = habit
            self._habitName = State(initialValue: habit.name)
            self._habitUnit = State(initialValue: habit.unit)
            self._selectedIcon = State(initialValue: habit.icon)
            self._selectedColorIndex = State(initialValue: Edit.colorIndex(for: habit.color))
            self._targetValue = State(initialValue: habit.target)
            self._habitKind = State(initialValue: habit.kind)
        }

        var body: some View {
            NavigationStack {
                Habit.Dashboard.Sheet(
                    initial: .init(
                        name: habit.name,
                        unit: habit.unit,
                        icon: habit.icon,
                        color: habit.color,
                        target: habit.target,
                        kind: habit.kind
                    ),
                    submitLabel: "Update Habit",
                    submitIcon: "checkmark",
                    onSubmit: { newHabit in
                        dashboardManager.updateHabit(habit, with: newHabit)
                        dismiss()
                    }
                )
                .toolbar { closeButtonToolbar }
                .presentationBackground {
                    Rectangle()
                        .fill(.thickMaterial)
                        .padding(.bottom, -100)
                }
                .presentationDetents([.large])
                .interactiveDismissDisabled()
                .navigationTitle("Edit Habit")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
        
    }
    
}

extension Habit.Dashboard.Sheet.Edit {

    private var isFormValid: Bool {
        !habitName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !habitUnit.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        targetValue != nil && targetValue! > 0
    }

    private var closeButtonToolbar: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button(role: .cancel) {
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .tint(.red)
        }
    }

    private var updateButton: some View {
        Button(role: .none) {
            updateHabit()
        } label: {
            Label("Update Habit", systemImage: "checkmark")
                .fontWeight(.semibold)
        }
        .buttonStyle(.borderedProminent)
        .buttonBorderShape(.capsule)
        .tint(.blue)
        .disabled(!isFormValid)
    }
    
    private func updateHabit() {
        guard isFormValid else { return }
        guard let targetValue else { return }
        
        dashboardManager.updateHabit(
            habit,
            name: habitName.trimmingCharacters(in: .whitespacesAndNewlines),
            unit: habitUnit.trimmingCharacters(in: .whitespacesAndNewlines),
            icon: selectedIcon,
            color: Habit.Dashboard.Sheet.availableColors[selectedColorIndex],
            target: targetValue,
            kind: habitKind
        )
        dismiss()
    }
    
    static func colorIndex(for color: Color) -> Int {
        // Convert the color to a comparable format and find the best match
        // For now, we'll use a simple approach by comparing against known colors
        let availableColors = Habit.Dashboard.Sheet.availableColors
        
        // Try to match by creating UIColors and comparing their components
        let targetUIColor = UIColor(color)
        var targetRed: CGFloat = 0, targetGreen: CGFloat = 0, targetBlue: CGFloat = 0, targetAlpha: CGFloat = 0
        targetUIColor.getRed(&targetRed, green: &targetGreen, blue: &targetBlue, alpha: &targetAlpha)
        
        var bestMatchIndex = 0
        var bestDistance = CGFloat.greatestFiniteMagnitude
        
        for (index, availableColor) in availableColors.enumerated() {
            let availableUIColor = UIColor(availableColor)
            var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
            availableUIColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
            
            // Calculate Euclidean distance in RGB space
            let distance = sqrt(
                pow(targetRed - red, 2) +
                pow(targetGreen - green, 2) +
                pow(targetBlue - blue, 2)
            )
            
            if distance < bestDistance {
                bestDistance = distance
                bestMatchIndex = index
            }
        }
        
        return bestMatchIndex
    }

}
// ./Habit Rabbit/Views/DetailView/DetailView.Manager.swift
import SwiftUI
import SwiftData

extension Habit.Card.DetailView {
    
    @Observable
    class Manager {

        private let habit: Habit
        private let modelContext: ModelContext
        
        private(set) var values: [Habit.Value] = []
        private(set) var isLoading = false
        private(set) var canLoadMore = false
        
        private let pageSize = 100
        private var currentOffset = 0
        
        init(for habit: Habit, using modelContext: ModelContext) {
            self.habit = habit
            self.modelContext = modelContext
            loadInitialValues()
        }
        
        var name: String { habit.name }
        var unit: String { habit.unit }
        var icon: String { habit.icon }
        var color: Color { habit.color }
        var target: Int { habit.target }
        var kind: Habit.Kind { habit.kind }
    
    }
    
}

extension Habit.Card.DetailView.Manager {
    
    func loadInitialValues() {
        loadValues(reset: true)
    }
    
    func loadMoreValues() {
        guard !isLoading && canLoadMore else { return }
        loadValues(reset: false)
    }
    
    private func loadValues(reset: Bool) {
        isLoading = true
        
        if reset {
            currentOffset = 0
            values = []
        }
        
        let habitID = habit.id
        
        let predicate = #Predicate<Habit.Value> {
            $0.habit?.persistentModelID == habitID
            && $0.currentValue > 0
        }
        
        let dateSort = SortDescriptor(\Habit.Value.date, order: .reverse)
        
        var descriptor = FetchDescriptor(predicate: predicate, sortBy: [dateSort])
        descriptor.fetchLimit = pageSize
        descriptor.fetchOffset = currentOffset
        descriptor.relationshipKeyPathsForPrefetching = [\Habit.Value.habit]
        
        do {
            let fetchedValues = try modelContext.fetch(descriptor)
            
            if reset {
                values = fetchedValues
            } else {
                values.append(contentsOf: fetchedValues)
            }
            
            currentOffset += fetchedValues.count
            canLoadMore = fetchedValues.count == pageSize
        } catch {
            canLoadMore = false
        }
        
        isLoading = false
    }
    
    func resetValue(_ value: Habit.Value) {
        value.currentValue = 0
        try? modelContext.save()
    }
    
    func updateValue(_ value: Habit.Value, to newValue: Int) {
        value.currentValue = newValue
        try? modelContext.save()
    }
    
}
// ./Habit Rabbit/Views/DetailView/DetailView.swift
import SwiftUI
import SwiftData

extension Habit.Card {

    struct DetailView: View {

        @Environment(\.colorScheme) var colorScheme
        @Environment(Habit.Card.Manager.self) var cardManager
        @Environment(Habit.Dashboard.Manager.self) var dashboardManager

        @State var detailManager: Habit.Card.DetailView.Manager?
        var values: [Habit.Value] { detailManager?.values ?? [] }
        
        @State var editingValue: Habit.Value?
        @State var editValueText: String = ""
        
        var body: some View {
            Group {
                if let detailManager {
                    valuesList
                        .safeAreaInset(edge: .bottom, spacing: 0) { loadMoreButton }
                        .contentMargins(.top, 16)
                        .environment(detailManager)
                } else {
                    loadingView
                }
            }
            .navigationTitle(cardManager.habit.name)
            .navigationBarTitleDisplayMode(.inline)
            .onAppear { setupDetailManager() }
            .alert("Edit Value",
                isPresented: .constant(editingValue != nil),
                actions: { editValueAlert },
                message: { editValueMessage }
            )
        }

    }

}

extension Habit.Card.DetailView {
    
    func setupDetailManager() {
        if detailManager == nil {
            detailManager = Habit.Card.DetailView.Manager(
                for: cardManager.habit,
                using: dashboardManager.modelContext
            )
        }
    }
    
}
// ./Habit Rabbit/Views/DetailView/Views/DetailView.loadingViews.swift
import SwiftUI

extension Habit.Card.DetailView {

    var loadingView: some View {
        ProgressView()
            .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    @ViewBuilder
    var emptyView: some View {
        if values.isEmpty {
            ContentUnavailableView(
                "No Values",
                systemImage: "text.page.slash",
                description: Text("Start tracking to see your progress history here.")
            )
            .frame(height: 200)
            .frame(maxHeight: .infinity, alignment: .top)
            .padding(.top, 16)
        }
    }
    
    @ViewBuilder
    var loadMoreButton: some View {
        if detailManager?.canLoadMore ?? false {
            Button {
                detailManager?.loadMoreValues()
            } label: {
                HStack {
                    if detailManager?.isLoading == true {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Text("Load More Values")
                    }
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
            }
            .disabled(detailManager?.isLoading == true)
            .padding(.horizontal)
            .padding(.bottom, 8)
        }
    }

}
// ./Habit Rabbit/Views/DetailView/Views/DetailView.valueList.swift
import SwiftUI

extension Habit.Card.DetailView {

    @ViewBuilder
    var valuesList: some View {
        List(values) { value in
            valueRow(for: value)
                .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                    swipeButtons(for: value)
                }
                .contextMenu {
                    swipeButtons(for: value)
                }
        }
        .safeAreaInset(edge: .top) { emptyView }
    }
    
    func valueRow(for value: Habit.Value) -> some View {
        HStack {
            Habit.Card.Cube(
                value: value,
                habit: cardManager.habit
            )
            Text(verbatim: "\(value.date.formatted(.date))")
            Spacer()
            Text(verbatim: "\(value.currentValue)")
        }
    }

}

extension Habit.Card.DetailView {
    
    @ViewBuilder
    func swipeButtons(for value: Habit.Value) -> some View {
        Button("Edit", systemImage: "pencil") {
            editingValue = value
            editValueText = "\(value.currentValue)"
        }
        .tint(.blue)
        .labelStyle(.iconOnly)
        
        Button("Reset", systemImage: "trash") {
            detailManager?.resetValue(value)
        }
        .tint(.red)
        .labelStyle(.iconOnly)
    }
    
    @ViewBuilder
    var editValueMessage: some View {
        if let value = editingValue {
            Text("Enter new value for \(value.date.formatted(.date))")
        }
    }
    
    @ViewBuilder
    var editValueAlert: some View {
        TextField("Value", text: $editValueText)
            .keyboardType(.numberPad)
        Button("Cancel", action: cancelEdit)
        Button("Save", action: saveEdit)
    }
    
    private func cancelEdit() {
        editingValue = nil
        editValueText = ""
    }
    
    private func saveEdit() {
        if let value = editingValue,
           let newValue = Int(editValueText) {
            detailManager?.updateValue(value, to: newValue)
        }
        editingValue = nil
        editValueText = ""
    }
    
}
// ./Habit Rabbit/Views/Other/ProgressButton.swift
import SwiftUI

extension Habit {
    
    struct ProgressButton: View {
        
        @Environment(\.colorScheme) private var colorScheme
        @Environment(\.cardMode) var cardMode
        
        @Environment(Habit.Card.Manager.self) private var cardManager
        
        var mode: Habit.Card.Mode {
            cardMode ?? cardManager.mode
        }
        
        var body: some View {
            Button {
                cardManager.dailyValue?.currentValue += 1
            } label: {
                ZStack {
                    Circle()
                        .fill(.quaternary)
                    Circle()
                        .fill(cardManager.color.gradient)
                        .brightness(buttonBrightness)
                        .clipShape(.capsule)
                        .padding(3)
                        .animation(.default, value: buttonBrightness)
                    
                    Image(systemName: "plus")
                        .font(.title)
                        .fontWeight(.medium)
                        .foregroundStyle(.white)
                }
            }
            .buttonStyle(.plain)
            .sensoryFeedback(.increase, trigger: cardManager.dailyValue?.currentValue)
        }
        
    }
    
}

extension Habit.ProgressButton {
    
    var buttonBrightness: Double {
        let isDark = colorScheme == .dark
        let exceedsTarget = cardManager.currentValue(for: mode) > cardManager.habit.target
        
        return switch (cardManager.habit.kind, isDark, exceedsTarget) {
            case (.good, true, true)   :  0.1   // exceeding good habit in dark mode: brighter
            case (.good, true, false)  : -0.1   // not exceeding good habit in dark mode: darker
            case (.good, false, true)  : -0.1   // exceeding good habit in light mode: darker
            case (.good, false, false) :  0.1   // not exceeding good habit in light mode: brighter
            case (.bad, _, _)          :  0     // bad habits: no adjustment
        }
    }
    
}
// ./Habit Rabbit/Views/Other/ProgressLabel.swift
import SwiftUI

extension Habit {

    struct ProgressLabel: View {

        @Environment(\.colorScheme) var colorScheme

        let value: Int
        let target: Int
        let unit: String

        var body: some View {
            switch target {
                case   ...99: singleLineLabel
                case ...9999: multiLineLabel
                default: multiLineLabelSmall
            }
        }

    }
    
}

extension Habit.ProgressLabel {
    
    var singleLineLabel: some View {
        VStack(spacing: 2) {
            (
                Text(verbatim: "\(value)")
                    .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                +
                Text(verbatim: " / ")
                    .foregroundStyle(.primary.opacity(0.6))
                +
                Text(verbatim: "\(target)")
                    .foregroundStyle(.primary.opacity(0.6))
            )
            .font(.title2)
            .fontWeight(.semibold)
            .monospacedDigit()
            .contentTransition(.numericText())
            
            Text(verbatim: unit.pluralized(count: target))
                .font(.footnote)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity)
        .minimumScaleFactor(0.7)
        .lineLimit(1)
        .padding(.horizontal, 2)
    }
    
    var multiLineLabel: some View {
        VStack(spacing: 0) {
            Text("\(value)")
                .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                .overlay(alignment: .trailing) {
                    Text("/")
                        .foregroundStyle(.primary.opacity(0.6))
                        .offset(x: 12)
                }
                
            Text("\(target)")
                .foregroundStyle(.primary.opacity(0.6))
            
            Text(verbatim: unit.pluralized(count: target))
                .font(.footnote)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
                .padding(.top, 2)
                .offset(x: 2)
        }
        .font(.title3)
        .fontWeight(.semibold)
        .monospacedDigit()
        .contentTransition(.numericText())
        .minimumScaleFactor(0.7)
        .lineLimit(1)
        .offset(x: -2)
    }
    
    var multiLineLabelSmall: some View {
        VStack(spacing: 0) {
            Text("\(value)")
                .foregroundStyle(.primary.opacity(colorScheme == .dark ? 1 : 0.8))
                .overlay(alignment: .trailing) {
                    Text("/")
                        .foregroundStyle(.primary.opacity(0.6))
                        .offset(x: 10)
                }
                
            Text("\(target)")
                .foregroundStyle(.primary.opacity(0.6))
            
            Text(verbatim: unit.pluralized(count: target))
                .font(.footnote)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
                .padding(.top, 2)
                .offset(x: 2)
        }
        .font(.headline)
        .fontWeight(.semibold)
        .monospacedDigit()
        .contentTransition(.numericText())
        .minimumScaleFactor(0.7)
        .lineLimit(1)
        .offset(x: -2)
    }
    
}
// ./Habit Rabbit/Views/Other/SegmentedControl.swift
import SwiftUI

struct SegmentedControl<T: Hashable>: View {

    @Binding var selection: T
    let options: [(value: T, icon: String, text: String, color: Color)]
    
    @State private var selectedIndex: Int = 0
    
    private var selectedOptionColor: Color {
        guard let index = options.firstIndex(where: { $0.value == selection }) else { return .blue }
        return options[index].color
    }
    
    var body: some View {
        GeometryReader { geometry in
            let segmentWidth = geometry.size.width / CGFloat(options.count)
            
            ZStack {
                // Background
                RoundedRectangle(cornerRadius: 10)
                    .fill(.quaternary)
                
                // Moving selected background
                RoundedRectangle(cornerRadius: 10)
                    .fill(selectedOptionColor)
                    .frame(width: segmentWidth - 4, height: geometry.size.height - 4)
                    .offset(x: CGFloat(selectedIndex) * segmentWidth - geometry.size.width / 2 + segmentWidth / 2)
                
                // Segment buttons
                HStack(spacing: 0) {
                    ForEach(options.enumerated, id: \.offset) { index, option in
                        Button {
                            withAnimation {
                                selection = option.value
                                selectedIndex = index
                            }
                        } label: {
                            HStack(spacing: 6) {
                                Image(systemName: option.icon)
                                    .font(.system(size: 16, weight: .semibold))
                                Text(option.text)
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .foregroundColor(selection == option.value ? .white : .secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .contentShape(.rect)
                        }
                        .buttonStyle(.plain)
                    }
                }
            }
        }
        .frame(height: 44)
        .padding(2)
        .onAppear {
            if let index = options.firstIndex(where: { $0.value == selection }) {
                selectedIndex = index
            }
        }
        .onChange(of: selection) { _, newValue in
            if let index = options.firstIndex(where: { $0.value == newValue }) {
                selectedIndex = index
            }
        }
    }
    
}
// ./Habit Rabbit/Views/Other/WeekdaySymbol.swift
import SwiftUI

extension Habit {
    
    struct WeekdaySymbol: View {
        
        let symbol: String
        let color: Color
        
        var body: some View {
            Text(symbol)
                .font(.caption2)
                .fontWeight(.medium)
                .foregroundStyle(color)
                .lineLimit(1)
        }
        
    }
    
}
// ./Habit Rabbit/Views/Other/ProgressBar/ProgressBar.geometry.swift
import SwiftUI

extension Habit.ProgressBar {
    
    var progress: CGFloat {
        guard target > 0 else { return 0 }
        return CGFloat(value) / CGFloat(target)
    }
    
    var offset: CGFloat {
        let dimension = axis == .vertical ? height : width
        
        let base = switch (kind, axis) {
            case (.good, .vertical)   :  dimension - inset * 2    // fills upward
            case (.good, .horizontal) : -dimension                // fills rightward
            case (.bad, .vertical)    :  dimension - inset * 2    // depletes downward
            case (.bad, .horizontal)  : -dimension                // depletes leftward
        }
        
        return switch kind {
            case .good:
                switch progress {
                    case  ...0: base
                    case 0..<1: base * (1 - compensate(progress))
                    case  1...: 0
                    default   : base
                }
            case .bad:
                switch progress {
                    case  ...0: 0
                    case 0..<1: base * (1 - compensate(1 - progress))
                    case  1...: base
                    default   : 0
                }
        }
    }
    
}

extension Habit.ProgressBar {
    
    // boosts mid-range values to compensate the visual shortening from rounded capsule caps
    private func compensate(_ progress: CGFloat) -> CGFloat {
        let clamped = max(0, min(1, progress))
        let lift = min(0.06, 0.04 + 0.6 * curvature)
        let bump = clamped * (1 - clamped)
        let power: CGFloat = 2
        let peak = pow(0.25, power)
        let scale = lift / peak
        let boost = scale * pow(bump, power)
        return max(0, min(1, clamped + boost))
    }
    
    // bar thickness relative to its usable track length
    private var curvature: CGFloat {
        let isVertical = axis == .vertical
        let thickness = isVertical ? width : height
        let length = isVertical ? height : width
        let inset = isVertical ? inset : 0
        let track = max(1, length - inset * 2)
        return min(1, thickness / track)
    }
    
}
// ./Habit Rabbit/Views/Other/ProgressBar/ProgressBar.style.swift
import SwiftUI

extension Habit.ProgressBar {
    
    private var isDark: Bool { colorScheme == .dark }
    private var isDaily: Bool { mode == .daily }
    private var exceedsTarget: Bool { value > target }
    
    var colorBrightness: Double {
        switch (kind, isDark, exceedsTarget) {
            case (.bad, _, _)          :  0     // bad habit: no adjustment
            case (.good, true, true)   :  0.1   // exceeding good habit in dark mode: brighter color
            case (.good, true, false)  : -0.1   // non-exceeding good habit in dark mode: darker color
            case (.good, false, true)  : -0.1   // exceeding good habit in light mode: darker color
            case (.good, false, false) :  0.1   // non-exceeding good habit in light mode: brighter color
        }
    }
    
    var trackBrightness: Double {
        switch (kind, isDark, exceedsTarget) {
            case (.good, _, _)       :  0.2   // good habits: no adjustment
            case (.bad, _, false)    :  0.2   // non-exceeding bad habit in dark mode: no adjustment
            case (.bad, true, true)  : -0.6   // exceeding bad habit in dark mode: much darker
            case (.bad, false, true) : -0.5   // exceeding bad habit in light mode: darker
        }
    }
    
    var trackBorderWidth: Double {
        switch (kind, isDark, exceedsTarget, isDaily) {
            case (.good, _, _, _)          :  0     // good habits: no stroke
            case (.bad, _, false, _)       :  0     // non-exceeding bad habit: no stroke
            case (.bad, false, true, _)    :  0     // exceeding bad habit in light mode: no stroke
            case (.bad, true, true, true)  :  1.5   // exceeding bad habit in daily dark mode: thick stroke
            case (.bad, true, true, false) :  0.75  // exceeding bad habit in other dark mode: medium stroke
        }
    }
    
}
// ./Habit Rabbit/Views/Other/ProgressBar/ProgressBar.swift
import SwiftUI

extension Habit {
    
    struct ProgressBar: View {
        
        @Environment(\.colorScheme) var colorScheme
        
        let value: Int
        let target: Int
        let color: Color
        let axis: Axis
        let kind: Habit.Kind
        let mode: Habit.Card.Mode
        let width: CGFloat
        let height: CGFloat
        
        let inset: CGFloat = 3
        
        var body: some View {
            Capsule()
                .fill(.quaternary)
                .strokeBorder(.quaternary, lineWidth: trackBorderWidth)
                .brightness(trackBrightness)
                .overlay {
                    Capsule()
                        .fill(color.gradient)
                        .brightness(colorBrightness)
                        .offset(
                            x: axis == .horizontal ? offset : 0,
                            y: axis == .vertical ? offset : 0
                        )
                        .shadow(color: .black.opacity(0.07), radius: 2, x: 0, y: -2)
                        .clipShape(.capsule)
                        .padding(axis == .vertical ? inset : 0)
                }
                .geometryGroup()
                .frame(width: width, height: height)
                .fixedSize()
                .animation(.bouncy, value: value)
        }
    }
    
}
